{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"IoP (Interoperability On Python) Welcome to the Interoperability On Python (IoP) proof of concept! This project demonstrates how the IRIS Interoperability Framework can be utilized with a Python-first approach . Example Here's a simple example of how a Business Operation can be implemented in Python: from iop import BusinessOperation class MyBo(BusinessOperation): def on_message(self, request): self.log_info(\"Hello World\") Installation To start using this proof of concept, install it using pip: pip install iris-pex-embedded-python Getting Started If you're new to this proof of concept, begin by reading the installation guide . Then, follow the first steps to create your first Business Operation. Happy coding!","title":"Home"},{"location":"#iop-interoperability-on-python","text":"Welcome to the Interoperability On Python (IoP) proof of concept! This project demonstrates how the IRIS Interoperability Framework can be utilized with a Python-first approach .","title":"IoP (Interoperability On Python)"},{"location":"#example","text":"Here's a simple example of how a Business Operation can be implemented in Python: from iop import BusinessOperation class MyBo(BusinessOperation): def on_message(self, request): self.log_info(\"Hello World\")","title":"Example"},{"location":"#installation","text":"To start using this proof of concept, install it using pip: pip install iris-pex-embedded-python","title":"Installation"},{"location":"#getting-started","text":"If you're new to this proof of concept, begin by reading the installation guide . Then, follow the first steps to create your first Business Operation. Happy coding!","title":"Getting Started"},{"location":"benchmarks/","text":"Benchmarks 8 senarios with thoses parameters : - 100 messages - body : simple string test Scenario Time (s) Python BP to Python BO with Iris Message 0.239 Python BP to Python BO with Python Message 0.232 ObjetScript BP to Python BO with Iris Message 0.294 ObjetScript BP to Python BO with Python Message 0.242 Python BP to ObjetScript BO with Iris Message 0.242 Python BP to ObjetScript BO with Python Message 0.275 ObjetScript BP to ObjetScript BO with Iris Message 0.159 ObjetScript BP to ObjetScript BO with Python Message 0.182 Benchmarked can be run in the unit test with the following command : pytest src/tests/test_bench.py","title":"Benchmarks"},{"location":"benchmarks/#benchmarks","text":"8 senarios with thoses parameters : - 100 messages - body : simple string test Scenario Time (s) Python BP to Python BO with Iris Message 0.239 Python BP to Python BO with Python Message 0.232 ObjetScript BP to Python BO with Iris Message 0.294 ObjetScript BP to Python BO with Python Message 0.242 Python BP to ObjetScript BO with Iris Message 0.242 Python BP to ObjetScript BO with Python Message 0.275 ObjetScript BP to ObjetScript BO with Iris Message 0.159 ObjetScript BP to ObjetScript BO with Python Message 0.182 Benchmarked can be run in the unit test with the following command : pytest src/tests/test_bench.py","title":"Benchmarks"},{"location":"changelog/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . [unreleased] - Unreleased Added Initial support for venv [3.4.4] - 2025-06-13 Added Changed %traceback setting default value is now True to show traceback in message log serializer is now more permissive for iris objects, allowing iris object type of %Stream to support http inbound/outbound adapters remove usage of pkg_resources in favor of importlib.resources refactor import statements for better clarity and organization Fixed fix typing issues in python code fix long string attribute from production settings ( greatter than 255 characters ) [3.4.3] - 2025-05-26 Fixed Fix a regression in DTL to display sub-objects Improve upgrade compatibility with 3.4.0 (pre-debugger) Changed Change debugger settings to be prefixed with % to avoid conflict with other settings Added Add %traceback setting to enable or disable traceback in message log [3.4.2] - 2025-05-2 Fixed Fix regression in version 3.4.0 and 3.4.1 where production settings were not properly loaded [3.4.1] - 2025-04-30 Added Add namespace selection in the iop command -n or --namespace option to select a namespace Initial remote debugging support Changed Change how iris module is loaded Create a new _iris module in the iop package Remove dependency on community driver Use iris module instead Fixed Fix dataclass message serialization Go back to best effort serialization : type check is not forced For checking use PydanticMessage Logger now uses the correct level for debug , info and similar methods [3.4.0] - 2025-03-24 Added Support for production settings configuration and management Enhanced Python logging integration with IRIS Support for schema registration with PydanticMessage Improved Pydantic integration for message validation Logger property in _Common class for better logging management Changed Refactored _director and _utils modules Enhanced serialization module Simplified type conversion Improved Pydantic integration Removed deprecated methods Remove dacite and dc-schema dependencies in favor of Pydantic Improved logging mechanism Encapsulated console logging behavior Enhanced logger initialization Updated pytest configuration for asyncio Fixed Fixed log handling in Command class Improved error handling in OnGetConnections method [3.3.0] - 2025-01-25 Added Support of Pydantic message validation and serialization Enhanced Python logging integration with LogManager New test framework with pytest-asyncio support Improved error handling and validation Changed Refactored core components for better maintainability Enhanced message serialization system Improved production settings handling Fixed Various log handling issues Message validation edge cases [3.2.0] - 2025-01-15 Added DTL (Data Transformation Layer) with JSON Schema support Complex JSON transformation capabilities Enhanced documentation for DTL features JsonPath support for data manipulation Comprehensive schema validation system Changed Improved message transformation handling Enhanced error reporting for schema validation Refactored transformation engine Fixed JSON Schema processing issues Array handling in transformations Various DTL edge cases [3.1.0] - 2024-07-26 Added Async function support in Business Processes and Operations Multi-sync call capabilities Enhanced trace logging options New benchmarking tools Improved session handling Changed Refactored business host dispatch system Enhanced message serialization Improved async request handling Fixed Retro-compatibility with grongier.pex Session management issues Various async operation bugs [3.0.0] - 2024-07-08 Changed Renamed package from grongier.pex to iop Major refactoring of core components Improved package structure Enhanced documentation Added New installation methods Better package management Improved error handling [2.3.24] - 2024-03-08 Added Dev mode support for WSGI applications Experimental iris module features Sugar syntax for common operations Enhanced intellisense support Improved WSGI configuration options Fixed PyPI version synchronization WSGI handling issues Device redirection in WSGI [2.3.20] - 2023-12-13 Fixed Fix upgrade version issues [2.3.19] - 2023-12-12 Added Support for OnGetConnections and on_get_connections to show connections between components in interoperability UI [2.3.18] - 2023-12-11 Fixed Named argument not serialized for send_request_sync and send_request_async [2.3.17] - 2023-11-24 Added Support relative path for migration [2.3.16] - 2023-10-30 Added Support of Japanese characters New command line options Logs number of line Start production async [2.3.12] - 2023-10-04 Added New command line option test Changed Refactored some code Fixed Various minor fixes [2.3.8] - 2023-07-13 Fixed iop --init command cls compilation with zpm [2.3.7] - 2023-07-07 Fixed Source dir and package for zpm [2.3.6] - 2023-07-07 Fixed ZPM installation [2.3.5] - 2023-07-05 Added Initial WSGI support Settings.py support Changed Aligned version with pypi [2.3.0] - 2023-05-31 Added Command line support Settings.py files support [2.2.0] - 2023-05-19 Added Manager support for production management Settings.py class support for component and production configuration Director support for production control and logging [2.1.0] - 2023-04-21 Added Support for Python 3.6 (RedHat 8.x) Deployment with PyPi Fixed Files and folders named with \"_\" Stronger check on Message [2.0.0] - 2023-03-15 Added Iop command line","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased-unreleased","text":"","title":"[unreleased] - Unreleased"},{"location":"changelog/#added","text":"Initial support for venv","title":"Added"},{"location":"changelog/#344-2025-06-13","text":"","title":"[3.4.4] - 2025-06-13"},{"location":"changelog/#added_1","text":"","title":"Added"},{"location":"changelog/#changed","text":"%traceback setting default value is now True to show traceback in message log serializer is now more permissive for iris objects, allowing iris object type of %Stream to support http inbound/outbound adapters remove usage of pkg_resources in favor of importlib.resources refactor import statements for better clarity and organization","title":"Changed"},{"location":"changelog/#fixed","text":"fix typing issues in python code fix long string attribute from production settings ( greatter than 255 characters )","title":"Fixed"},{"location":"changelog/#343-2025-05-26","text":"","title":"[3.4.3] - 2025-05-26"},{"location":"changelog/#fixed_1","text":"Fix a regression in DTL to display sub-objects Improve upgrade compatibility with 3.4.0 (pre-debugger)","title":"Fixed"},{"location":"changelog/#changed_1","text":"Change debugger settings to be prefixed with % to avoid conflict with other settings","title":"Changed"},{"location":"changelog/#added_2","text":"Add %traceback setting to enable or disable traceback in message log","title":"Added"},{"location":"changelog/#342-2025-05-2","text":"","title":"[3.4.2] - 2025-05-2"},{"location":"changelog/#fixed_2","text":"Fix regression in version 3.4.0 and 3.4.1 where production settings were not properly loaded","title":"Fixed"},{"location":"changelog/#341-2025-04-30","text":"","title":"[3.4.1] - 2025-04-30"},{"location":"changelog/#added_3","text":"Add namespace selection in the iop command -n or --namespace option to select a namespace Initial remote debugging support","title":"Added"},{"location":"changelog/#changed_2","text":"Change how iris module is loaded Create a new _iris module in the iop package Remove dependency on community driver Use iris module instead","title":"Changed"},{"location":"changelog/#fixed_3","text":"Fix dataclass message serialization Go back to best effort serialization : type check is not forced For checking use PydanticMessage Logger now uses the correct level for debug , info and similar methods","title":"Fixed"},{"location":"changelog/#340-2025-03-24","text":"","title":"[3.4.0] - 2025-03-24"},{"location":"changelog/#added_4","text":"Support for production settings configuration and management Enhanced Python logging integration with IRIS Support for schema registration with PydanticMessage Improved Pydantic integration for message validation Logger property in _Common class for better logging management","title":"Added"},{"location":"changelog/#changed_3","text":"Refactored _director and _utils modules Enhanced serialization module Simplified type conversion Improved Pydantic integration Removed deprecated methods Remove dacite and dc-schema dependencies in favor of Pydantic Improved logging mechanism Encapsulated console logging behavior Enhanced logger initialization Updated pytest configuration for asyncio","title":"Changed"},{"location":"changelog/#fixed_4","text":"Fixed log handling in Command class Improved error handling in OnGetConnections method","title":"Fixed"},{"location":"changelog/#330-2025-01-25","text":"","title":"[3.3.0] - 2025-01-25"},{"location":"changelog/#added_5","text":"Support of Pydantic message validation and serialization Enhanced Python logging integration with LogManager New test framework with pytest-asyncio support Improved error handling and validation","title":"Added"},{"location":"changelog/#changed_4","text":"Refactored core components for better maintainability Enhanced message serialization system Improved production settings handling","title":"Changed"},{"location":"changelog/#fixed_5","text":"Various log handling issues Message validation edge cases","title":"Fixed"},{"location":"changelog/#320-2025-01-15","text":"","title":"[3.2.0] - 2025-01-15"},{"location":"changelog/#added_6","text":"DTL (Data Transformation Layer) with JSON Schema support Complex JSON transformation capabilities Enhanced documentation for DTL features JsonPath support for data manipulation Comprehensive schema validation system","title":"Added"},{"location":"changelog/#changed_5","text":"Improved message transformation handling Enhanced error reporting for schema validation Refactored transformation engine","title":"Changed"},{"location":"changelog/#fixed_6","text":"JSON Schema processing issues Array handling in transformations Various DTL edge cases","title":"Fixed"},{"location":"changelog/#310-2024-07-26","text":"","title":"[3.1.0] - 2024-07-26"},{"location":"changelog/#added_7","text":"Async function support in Business Processes and Operations Multi-sync call capabilities Enhanced trace logging options New benchmarking tools Improved session handling","title":"Added"},{"location":"changelog/#changed_6","text":"Refactored business host dispatch system Enhanced message serialization Improved async request handling","title":"Changed"},{"location":"changelog/#fixed_7","text":"Retro-compatibility with grongier.pex Session management issues Various async operation bugs","title":"Fixed"},{"location":"changelog/#300-2024-07-08","text":"","title":"[3.0.0] - 2024-07-08"},{"location":"changelog/#changed_7","text":"Renamed package from grongier.pex to iop Major refactoring of core components Improved package structure Enhanced documentation","title":"Changed"},{"location":"changelog/#added_8","text":"New installation methods Better package management Improved error handling","title":"Added"},{"location":"changelog/#2324-2024-03-08","text":"","title":"[2.3.24] - 2024-03-08"},{"location":"changelog/#added_9","text":"Dev mode support for WSGI applications Experimental iris module features Sugar syntax for common operations Enhanced intellisense support Improved WSGI configuration options","title":"Added"},{"location":"changelog/#fixed_8","text":"PyPI version synchronization WSGI handling issues Device redirection in WSGI","title":"Fixed"},{"location":"changelog/#2320-2023-12-13","text":"","title":"[2.3.20] - 2023-12-13"},{"location":"changelog/#fixed_9","text":"Fix upgrade version issues","title":"Fixed"},{"location":"changelog/#2319-2023-12-12","text":"","title":"[2.3.19] - 2023-12-12"},{"location":"changelog/#added_10","text":"Support for OnGetConnections and on_get_connections to show connections between components in interoperability UI","title":"Added"},{"location":"changelog/#2318-2023-12-11","text":"","title":"[2.3.18] - 2023-12-11"},{"location":"changelog/#fixed_10","text":"Named argument not serialized for send_request_sync and send_request_async","title":"Fixed"},{"location":"changelog/#2317-2023-11-24","text":"","title":"[2.3.17] - 2023-11-24"},{"location":"changelog/#added_11","text":"Support relative path for migration","title":"Added"},{"location":"changelog/#2316-2023-10-30","text":"","title":"[2.3.16] - 2023-10-30"},{"location":"changelog/#added_12","text":"Support of Japanese characters New command line options Logs number of line Start production async","title":"Added"},{"location":"changelog/#2312-2023-10-04","text":"","title":"[2.3.12] - 2023-10-04"},{"location":"changelog/#added_13","text":"New command line option test","title":"Added"},{"location":"changelog/#changed_8","text":"Refactored some code","title":"Changed"},{"location":"changelog/#fixed_11","text":"Various minor fixes","title":"Fixed"},{"location":"changelog/#238-2023-07-13","text":"","title":"[2.3.8] - 2023-07-13"},{"location":"changelog/#fixed_12","text":"iop --init command cls compilation with zpm","title":"Fixed"},{"location":"changelog/#237-2023-07-07","text":"","title":"[2.3.7] - 2023-07-07"},{"location":"changelog/#fixed_13","text":"Source dir and package for zpm","title":"Fixed"},{"location":"changelog/#236-2023-07-07","text":"","title":"[2.3.6] - 2023-07-07"},{"location":"changelog/#fixed_14","text":"ZPM installation","title":"Fixed"},{"location":"changelog/#235-2023-07-05","text":"","title":"[2.3.5] - 2023-07-05"},{"location":"changelog/#added_14","text":"Initial WSGI support Settings.py support","title":"Added"},{"location":"changelog/#changed_9","text":"Aligned version with pypi","title":"Changed"},{"location":"changelog/#230-2023-05-31","text":"","title":"[2.3.0] - 2023-05-31"},{"location":"changelog/#added_15","text":"Command line support Settings.py files support","title":"Added"},{"location":"changelog/#220-2023-05-19","text":"","title":"[2.2.0] - 2023-05-19"},{"location":"changelog/#added_16","text":"Manager support for production management Settings.py class support for component and production configuration Director support for production control and logging","title":"Added"},{"location":"changelog/#210-2023-04-21","text":"","title":"[2.1.0] - 2023-04-21"},{"location":"changelog/#added_17","text":"Support for Python 3.6 (RedHat 8.x) Deployment with PyPi","title":"Added"},{"location":"changelog/#fixed_15","text":"Files and folders named with \"_\" Stronger check on Message","title":"Fixed"},{"location":"changelog/#200-2023-03-15","text":"","title":"[2.0.0] - 2023-03-15"},{"location":"changelog/#added_18","text":"Iop command line","title":"Added"},{"location":"code-of-conduct/","text":"Code of conduct TODO","title":"Code of Conduct"},{"location":"code-of-conduct/#code-of-conduct","text":"TODO","title":"Code of conduct"},{"location":"command-line/","text":"Command line Since version 2.3.1, you can use the command line to register your components and productions. To use it, you have to use the following command : iop output : usage: python3 -m iop [-h] [-d DEFAULT] [-l] [-s START] [-S] [-k] [-r] [-x] [-m MIGRATE] [-e EXPORT] [-v] [-L] [-i INIT] [-t TEST] [-D] [-C CLASSNAME] [-B BODY] optional arguments: -h, --help display help and default production name -d DEFAULT, --default DEFAULT set the default production -l, --list list productions -s START, --start START start a production -S, --stop stop a production -k, --kill kill a production -r, --restart restart a production -x, --status status a production -m MIGRATE, -M MIGRATE, --migrate MIGRATE migrate production and classes with settings file -e EXPORT, --export EXPORT export a production -v, --version display version -L, --log display log -i INIT, --init INIT init the pex module in iris -t TEST, --test TEST test the pex module in iris start arguments: -D, --detach start a production in detach mode test arguments: -C CLASSNAME, --classname CLASSNAME test classname -B BODY, --body BODY test body default production: IoP.Production help The help command display the help and the default production name. iop -h output : usage: python3 -m iop [-h] [-d DEFAULT] [-l] [-s START] [-S] [-k] [-r] [-x] [-m MIGRATE] [-e EXPORT] [-v] [-L] [-i INIT] [-t TEST] [-D] [-C CLASSNAME] [-B BODY] ... default production: IoP.Production default The default command set the default production. With no argument, it display the default production. iop -d output : default production: IoP.Production With an argument, it set the default production. iop -d IoP.Production lists The lists command list productions. iop -l output : { \"IoP.Production\": { \"Status\": \"Stopped\", \"LastStartTime\": \"2023-05-31 11:13:51.000\", \"LastStopTime\": \"2023-05-31 11:13:54.153\", \"AutoStart\": 0 } } start The start command starts a production. To exit the command, you have to press CTRL+C (unless using detach mode). iop -s IoP.Production You can start a production in detach mode using the -D flag: iop -s IoP.Production -D In detach mode, the production starts and the command returns immediately without showing logs. kill The kill command kill a production (force stop). Kill command is the same as stop command but with a force stop. Kill command doesn't take an argument because only one production can be running. iop -k stop The stop command stop a production. Stop command doesn't take an argument because only one production can be running. iop -S restart The restart command restart a production. Restart command doesn't take an argument because only one production can be running. iop -r migrate The migrate command migrate a production and classes with settings file. Migrate command must take the absolute path of the settings file. Settings file must be in the same folder as the python code. iop -M /tmp/settings.py More details about the settings file can be found here . init The init command initializes the IoP module in IRIS. iop -i test The test command allows testing IoP components. You can optionally specify a test name, classname, and body. Basic test: iop -t Test with specific classname: iop -t MyTest -C MyClass Test with body: iop -t MyTest -C MyClass -B \"test body\" export The export command export a production. If no argument is given, the export command export the default production. iop -e If an argument is given, the export command export the production given in argument. iop -e IoP.Production output : { \"Production\": { \"@Name\": \"IoP.Production\", \"@TestingEnabled\": \"true\", \"@LogGeneralTraceEvents\": \"false\", \"Description\": \"\", \"ActorPoolSize\": \"2\", \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@Category\": \"\", \"@ClassName\": \"Python.FileOperation\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"true\", \"@Schedule\": \"\", \"Setting\": [ { \"@Target\": \"Adapter\", \"@Name\": \"Charset\", \"#text\": \"utf-8\" }, { \"@Target\": \"Adapter\", \"@Name\": \"FilePath\", \"#text\": \"/irisdev/app/output/\" }, { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": \"path=/irisdev/app/output/\" } ] } ] } } status The status command status a production. Status command doesn't take an argument because only one production can be running. iop -x output : { \"Production\": \"IoP.Production\", \"Status\": \"stopped\" } Status can be : - stopped - running - suspended - troubled version The version command display the version. iop -v output : 2.3.0 log The log command display the log. To exit the command, you have to press CTRL+C. iop -L output : 2021-08-30 15:13:51.000 [IoP.Production] INFO: Starting production 2021-08-30 15:13:51.000 [IoP.Production] INFO: Starting item Python.FileOperation 2021-08-30 15:13:51.000 [IoP.Production] INFO: Starting item Python.EmailOperation ...","title":"Command Line Interface"},{"location":"command-line/#command-line","text":"Since version 2.3.1, you can use the command line to register your components and productions. To use it, you have to use the following command : iop output : usage: python3 -m iop [-h] [-d DEFAULT] [-l] [-s START] [-S] [-k] [-r] [-x] [-m MIGRATE] [-e EXPORT] [-v] [-L] [-i INIT] [-t TEST] [-D] [-C CLASSNAME] [-B BODY] optional arguments: -h, --help display help and default production name -d DEFAULT, --default DEFAULT set the default production -l, --list list productions -s START, --start START start a production -S, --stop stop a production -k, --kill kill a production -r, --restart restart a production -x, --status status a production -m MIGRATE, -M MIGRATE, --migrate MIGRATE migrate production and classes with settings file -e EXPORT, --export EXPORT export a production -v, --version display version -L, --log display log -i INIT, --init INIT init the pex module in iris -t TEST, --test TEST test the pex module in iris start arguments: -D, --detach start a production in detach mode test arguments: -C CLASSNAME, --classname CLASSNAME test classname -B BODY, --body BODY test body default production: IoP.Production","title":"Command line"},{"location":"command-line/#help","text":"The help command display the help and the default production name. iop -h output : usage: python3 -m iop [-h] [-d DEFAULT] [-l] [-s START] [-S] [-k] [-r] [-x] [-m MIGRATE] [-e EXPORT] [-v] [-L] [-i INIT] [-t TEST] [-D] [-C CLASSNAME] [-B BODY] ... default production: IoP.Production","title":"help"},{"location":"command-line/#default","text":"The default command set the default production. With no argument, it display the default production. iop -d output : default production: IoP.Production With an argument, it set the default production. iop -d IoP.Production","title":"default"},{"location":"command-line/#lists","text":"The lists command list productions. iop -l output : { \"IoP.Production\": { \"Status\": \"Stopped\", \"LastStartTime\": \"2023-05-31 11:13:51.000\", \"LastStopTime\": \"2023-05-31 11:13:54.153\", \"AutoStart\": 0 } }","title":"lists"},{"location":"command-line/#start","text":"The start command starts a production. To exit the command, you have to press CTRL+C (unless using detach mode). iop -s IoP.Production You can start a production in detach mode using the -D flag: iop -s IoP.Production -D In detach mode, the production starts and the command returns immediately without showing logs.","title":"start"},{"location":"command-line/#kill","text":"The kill command kill a production (force stop). Kill command is the same as stop command but with a force stop. Kill command doesn't take an argument because only one production can be running. iop -k","title":"kill"},{"location":"command-line/#stop","text":"The stop command stop a production. Stop command doesn't take an argument because only one production can be running. iop -S","title":"stop"},{"location":"command-line/#restart","text":"The restart command restart a production. Restart command doesn't take an argument because only one production can be running. iop -r","title":"restart"},{"location":"command-line/#migrate","text":"The migrate command migrate a production and classes with settings file. Migrate command must take the absolute path of the settings file. Settings file must be in the same folder as the python code. iop -M /tmp/settings.py More details about the settings file can be found here .","title":"migrate"},{"location":"command-line/#init","text":"The init command initializes the IoP module in IRIS. iop -i","title":"init"},{"location":"command-line/#test","text":"The test command allows testing IoP components. You can optionally specify a test name, classname, and body. Basic test: iop -t Test with specific classname: iop -t MyTest -C MyClass Test with body: iop -t MyTest -C MyClass -B \"test body\"","title":"test"},{"location":"command-line/#export","text":"The export command export a production. If no argument is given, the export command export the default production. iop -e If an argument is given, the export command export the production given in argument. iop -e IoP.Production output : { \"Production\": { \"@Name\": \"IoP.Production\", \"@TestingEnabled\": \"true\", \"@LogGeneralTraceEvents\": \"false\", \"Description\": \"\", \"ActorPoolSize\": \"2\", \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@Category\": \"\", \"@ClassName\": \"Python.FileOperation\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"true\", \"@Schedule\": \"\", \"Setting\": [ { \"@Target\": \"Adapter\", \"@Name\": \"Charset\", \"#text\": \"utf-8\" }, { \"@Target\": \"Adapter\", \"@Name\": \"FilePath\", \"#text\": \"/irisdev/app/output/\" }, { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": \"path=/irisdev/app/output/\" } ] } ] } }","title":"export"},{"location":"command-line/#status","text":"The status command status a production. Status command doesn't take an argument because only one production can be running. iop -x output : { \"Production\": \"IoP.Production\", \"Status\": \"stopped\" } Status can be : - stopped - running - suspended - troubled","title":"status"},{"location":"command-line/#version","text":"The version command display the version. iop -v output : 2.3.0","title":"version"},{"location":"command-line/#log","text":"The log command display the log. To exit the command, you have to press CTRL+C. iop -L output : 2021-08-30 15:13:51.000 [IoP.Production] INFO: Starting production 2021-08-30 15:13:51.000 [IoP.Production] INFO: Starting item Python.FileOperation 2021-08-30 15:13:51.000 [IoP.Production] INFO: Starting item Python.EmailOperation ...","title":"log"},{"location":"contributing/","text":"Contributing Run the unit tests To run the unit tests, you must follow the steps below: Create a virtual environment. python -m venv .venv source .venv/bin/activate Install the dependencies. pip install -r requirements-dev.txt Have a running IRIS instance. Here you can choose between: Local installation of IRIS Docker installation of IRIS Local installation of IRIS Install IRIS locally. Local installation of IRIS Python interpreter compatible with the version of IRIS Iris embedded python wrapper Make sure to follow the instructions to install the wrapper in your IRIS instance. Set up the IRIS instance. Then, symbolically this git to the IRIS pyhton directory: ln -s <your_git_dir>/src/iop $IRISINSTALLDIR/python/iop Run the unit tests. pytest Docker installation of IRIS No prerequisites are needed. Just run the following command: docker build -t pytest-iris -f dockerfile-ci . docker run -i --rm pytest-iris","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#run-the-unit-tests","text":"To run the unit tests, you must follow the steps below:","title":"Run the unit tests"},{"location":"contributing/#create-a-virtual-environment","text":"python -m venv .venv source .venv/bin/activate","title":"Create a virtual environment."},{"location":"contributing/#install-the-dependencies","text":"pip install -r requirements-dev.txt","title":"Install the dependencies."},{"location":"contributing/#have-a-running-iris-instance","text":"Here you can choose between: Local installation of IRIS Docker installation of IRIS","title":"Have a running IRIS instance."},{"location":"contributing/#local-installation-of-iris","text":"","title":"Local installation of IRIS"},{"location":"contributing/#install-iris-locally","text":"Local installation of IRIS Python interpreter compatible with the version of IRIS Iris embedded python wrapper Make sure to follow the instructions to install the wrapper in your IRIS instance.","title":"Install IRIS locally."},{"location":"contributing/#set-up-the-iris-instance","text":"Then, symbolically this git to the IRIS pyhton directory: ln -s <your_git_dir>/src/iop $IRISINSTALLDIR/python/iop","title":"Set up the IRIS instance."},{"location":"contributing/#run-the-unit-tests_1","text":"pytest","title":"Run the unit tests."},{"location":"contributing/#docker-installation-of-iris","text":"No prerequisites are needed. Just run the following command: docker build -t pytest-iris -f dockerfile-ci . docker run -i --rm pytest-iris","title":"Docker installation of IRIS"},{"location":"credits/","text":"Credits Most of the code came from PEX for Python by Mo Cheng and Summer Gerry.","title":"Credits"},{"location":"credits/#credits","text":"Most of the code came from PEX for Python by Mo Cheng and Summer Gerry.","title":"Credits"},{"location":"debug/","text":"Debug How to debug IoP code. Before anything, I will put some context about IoP and IRIS. Next I will show how to debug the code. Finally, we will give some tips about debugging. Context IoP is a Python library that helps to build interoperability solutions with IRIS. IoP is based on Embedded Python in IRIS . Embedded Python is a feature of IRIS that allows you to run Python code inside IRIS. That means the python code is not running by a python interpreter, but by an IRIS process. Remote Debugging To remote debbug your code, you need IoP version 3.4.1 or later. You will then have access to new options in the management portal. Debugging Options Enable Debugging : This option will enable the remote debugging. Debugging Port : This option will set the port for the remote debugging. The default port is 0. If you set it to 0, the system will choose a random port. You can also set it to a specific port. Debugging Interpreter : In the background, the system will create a new python interpreter. This option will set the interpreter to use. In most cases, you don't need to change this option. Then when you start the process, you will see the following message in the logs: This means that the system is waiting for a connection on the port you set. Then you can connect to the port with your IDE. If you wait too long, the system will close the port and you will need to restart the process. If VsCode is connected to the port, you will see the following message in the logs: This means that the system is connected to the port and you can start debugging. Debugging with VSCode To debug the code with VSCode, you need to have the following: - VSCode - Python extension Then you need to create a new launch configuration for remote debugging. You can follow the steps in the VSCode documentation to initialize the configurations. You can also use the following configuration: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Python: Remote Debug\", \"type\": \"python\", \"request\": \"attach\", \"connect\": { \"host\": \"<IRIS_HOST>\", \"port\": <IRIS_DEBUG_PORT> }, \"pathMappings\": [ { \"localRoot\": \"${workspaceFolder}\", \"remoteRoot\": \"/irisdev/app\" // for example path inside the container } ], } ] } You need to change the <IRIS_HOST> and <IRIS_DEBUG_PORT> to the host and port of your IRIS instance. You also need to change the pathMappings to the path of your python file in IRIS and the path of your python file in your local machine. The path in IRIS is the path of the file in the IRIS instance. The path in your local machine is the path of the file in your local machine. Example Local Debugging The idea of local debugging is to use an native python interpreter and run the code outside IRIS. This way you can use the python debugger. The main issue with this approach is that you must have a local instance of IRIS to be able to run the code. When I mean a local instance, it can be a local installation of IRIS, or a docker container running IRIS. I will explain first with a local installation of IRIS. Then I will show how to do the same with a docker container. Local Installation To debug the code with a local installation of IRIS, you need to have the following: Local installation of IRIS Python interpreter compatible with the version of IRIS Iris embedded python wrapper After you have all the requirements, you can start the IRIS instance and run the python code. Debugging To debug the code, you can use the python debugger. Example with VsCode: Open the code in VsCode to an existing folder. For example, you can use this git repository: git clone https://github.com/grongierisc/iris-python-interoperability-template Open the folder iris-python-interoperability-template in VsCode. code iris-python-interoperability-template Install the python extension. Go to the extensions tab and search for Python . Create a virtual environment and select it. python -m venv .venv source .venv/bin/activate And select the virtual environment in VsCode. Install the dependencies. pip install -r requirements.txt Run the code in debug mode. Open the file src/python/reddit/bo.py , put a breakpoint in the line 26. And run the code in debug mode. And you can debug the code. Docker Container The general idea is the same as the local installation. The main difference is that you need to have a attached VSCode to the docker container. For that, you can use the Remote - Containers extension. Then you can attach the VSCode to the docker container and follow the same steps as the local installation. Tips Use unit tests The best way to debug the code is to use unit tests. You can use the python unittest library to write unit tests or pytest. You have examples in iris-python-interoperability-template . Use if name == ' main ' You can use the if __name__ == '__main__': to run the code only when you run the python file. Example: def my_function(): print('Hello World') if __name__ == '__main__': my_function() You also have examples in iris-python-interoperability-template . Use tracebacks Since iop version 3.4.3, you can use the %traceback setting to enable or disable tracebacks in the message log. This can help you to see the stack trace of the error and understand what is happening in the code. With traebacks enabled: With tracebacks disabled:","title":"Debugging"},{"location":"debug/#debug","text":"How to debug IoP code. Before anything, I will put some context about IoP and IRIS. Next I will show how to debug the code. Finally, we will give some tips about debugging.","title":"Debug"},{"location":"debug/#context","text":"IoP is a Python library that helps to build interoperability solutions with IRIS. IoP is based on Embedded Python in IRIS . Embedded Python is a feature of IRIS that allows you to run Python code inside IRIS. That means the python code is not running by a python interpreter, but by an IRIS process.","title":"Context"},{"location":"debug/#remote-debugging","text":"To remote debbug your code, you need IoP version 3.4.1 or later. You will then have access to new options in the management portal.","title":"Remote Debugging"},{"location":"debug/#debugging-options","text":"Enable Debugging : This option will enable the remote debugging. Debugging Port : This option will set the port for the remote debugging. The default port is 0. If you set it to 0, the system will choose a random port. You can also set it to a specific port. Debugging Interpreter : In the background, the system will create a new python interpreter. This option will set the interpreter to use. In most cases, you don't need to change this option. Then when you start the process, you will see the following message in the logs: This means that the system is waiting for a connection on the port you set. Then you can connect to the port with your IDE. If you wait too long, the system will close the port and you will need to restart the process. If VsCode is connected to the port, you will see the following message in the logs: This means that the system is connected to the port and you can start debugging.","title":"Debugging Options"},{"location":"debug/#debugging-with-vscode","text":"To debug the code with VSCode, you need to have the following: - VSCode - Python extension Then you need to create a new launch configuration for remote debugging. You can follow the steps in the VSCode documentation to initialize the configurations. You can also use the following configuration: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Python: Remote Debug\", \"type\": \"python\", \"request\": \"attach\", \"connect\": { \"host\": \"<IRIS_HOST>\", \"port\": <IRIS_DEBUG_PORT> }, \"pathMappings\": [ { \"localRoot\": \"${workspaceFolder}\", \"remoteRoot\": \"/irisdev/app\" // for example path inside the container } ], } ] } You need to change the <IRIS_HOST> and <IRIS_DEBUG_PORT> to the host and port of your IRIS instance. You also need to change the pathMappings to the path of your python file in IRIS and the path of your python file in your local machine. The path in IRIS is the path of the file in the IRIS instance. The path in your local machine is the path of the file in your local machine.","title":"Debugging with VSCode"},{"location":"debug/#example","text":"","title":"Example"},{"location":"debug/#local-debugging","text":"The idea of local debugging is to use an native python interpreter and run the code outside IRIS. This way you can use the python debugger. The main issue with this approach is that you must have a local instance of IRIS to be able to run the code. When I mean a local instance, it can be a local installation of IRIS, or a docker container running IRIS. I will explain first with a local installation of IRIS. Then I will show how to do the same with a docker container.","title":"Local Debugging"},{"location":"debug/#local-installation","text":"To debug the code with a local installation of IRIS, you need to have the following: Local installation of IRIS Python interpreter compatible with the version of IRIS Iris embedded python wrapper After you have all the requirements, you can start the IRIS instance and run the python code.","title":"Local Installation"},{"location":"debug/#debugging","text":"To debug the code, you can use the python debugger. Example with VsCode: Open the code in VsCode to an existing folder. For example, you can use this git repository: git clone https://github.com/grongierisc/iris-python-interoperability-template Open the folder iris-python-interoperability-template in VsCode. code iris-python-interoperability-template Install the python extension. Go to the extensions tab and search for Python . Create a virtual environment and select it. python -m venv .venv source .venv/bin/activate And select the virtual environment in VsCode. Install the dependencies. pip install -r requirements.txt Run the code in debug mode. Open the file src/python/reddit/bo.py , put a breakpoint in the line 26. And run the code in debug mode. And you can debug the code.","title":"Debugging"},{"location":"debug/#docker-container","text":"The general idea is the same as the local installation. The main difference is that you need to have a attached VSCode to the docker container. For that, you can use the Remote - Containers extension. Then you can attach the VSCode to the docker container and follow the same steps as the local installation.","title":"Docker Container"},{"location":"debug/#tips","text":"","title":"Tips"},{"location":"debug/#use-unit-tests","text":"The best way to debug the code is to use unit tests. You can use the python unittest library to write unit tests or pytest. You have examples in iris-python-interoperability-template .","title":"Use unit tests"},{"location":"debug/#use-if-name-main","text":"You can use the if __name__ == '__main__': to run the code only when you run the python file. Example: def my_function(): print('Hello World') if __name__ == '__main__': my_function() You also have examples in iris-python-interoperability-template .","title":"Use if name == 'main'"},{"location":"debug/#use-tracebacks","text":"Since iop version 3.4.3, you can use the %traceback setting to enable or disable tracebacks in the message log. This can help you to see the stack trace of the error and understand what is happening in the code. With traebacks enabled: With tracebacks disabled:","title":"Use tracebacks"},{"location":"dtl/","text":"DTL Support Starting with version 3.2.0, IoP supports DTL transformations. DTL the Data Transformation Layer in IRIS Interoperability. DTL transformations are used to transform data from one format to another with a graphical editor. It supports also jsonschema structures. How to use DTL in with Message First you need to register you message class is a settings.py file. To do so, you need to add the following line in the settings.py file: settings.py from msg import MyMessage SCHEMAS = [MyMessage] Then you can use iop migration command to generate schema files for your message classes. iop --migrate /path/to/your/project/settings.py Example msg.py from iop import Message from dataclasses import dataclass @dataclass class MyMessage(Message): name: str = None age: int = None settings.py from msg import MyMessage SCHEMAS = [MyMessage] Migrate the schema files iop --migrate /path/to/your/project/settings.py Building a DTL Transformation To build a DTL transformation, you need to create a new DTL transformation class. Go to the IRIS Interoperability Management Portal and create a new DTL transformation. Then select the source and target message classes. And it's schema. Then you can start building your transformation. You can even test your transformation. Example of payload to test as a source message: <test> <Message> <json><![CDATA[ { \"list_str\":[\"toto\",\"titi\"], \"post\":{\"Title\":\"foo\",\"Selftext\":\"baz\"}, \"list_post\":[{\"Title\":\"bar\",\"Selftext\":\"baz\"},{\"Title\":\"foo\",\"Selftext\":\"foo\"}] } ]]></json> </Message> </test> JsonSchema Support Starting with version 3.2.0, IoP supports jsonschema structures for DTL transformations. Same as for message classes, you need to register your jsonschema . To do so, you need to invoke his iris command: zw ##class(IOP.Message.JSONSchema).ImportFromFile(\"/irisdev/app/random_jsonschema.json\",\"Demo\",\"Demo\") Where the first argument is the path to the jsonschema file, the second argument is the package name and the third argument is the name of the schema. Then you can use it in your DTL transformation. The schema will be available in the name of Demo . Example jsonschema file: { \"$schema\": \"https://json-schema.org/draft/2020-12/schema\", \"type\": \"object\", \"title\": \"PostMessage\", \"properties\": { \"post\": { \"allOf\": [ { \"$ref\": \"#/$defs/PostClass\" } ] }, \"to_email_address\": { \"type\": \"string\", \"default\": null }, \"my_list\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } }, \"found\": { \"type\": \"string\", \"default\": null }, \"list_of_post\": { \"type\": \"array\", \"items\": { \"allOf\": [ { \"$ref\": \"#/$defs/PostClass\" } ] } } }, \"$defs\": { \"PostClass\": { \"type\": \"object\", \"title\": \"PostClass\", \"properties\": { \"title\": { \"type\": \"string\" }, \"selftext\": { \"type\": \"string\" }, \"author\": { \"type\": \"string\" }, \"url\": { \"type\": \"string\" }, \"created_utc\": { \"type\": \"number\" }, \"original_json\": { \"type\": \"string\", \"default\": null } }, \"required\": [ \"title\", \"selftext\", \"author\", \"url\", \"created_utc\" ] } } } Example of DTL Transformation with JsonSchema or Message Class Many can be found in the UnitTest package ./src/tests/cls directory. Class UnitTest.ComplexTransform Extends Ens.DataTransformDTL [ DependsOn = IOP.Message ] { Parameter IGNOREMISSINGSOURCE = 1; Parameter REPORTERRORS = 1; Parameter TREATEMPTYREPEATINGFIELDASNULL = 0; XData DTL [ XMLNamespace = \"http://www.intersystems.com/dtl\" ] { <transform sourceClass='IOP.Message' targetClass='IOP.Message' sourceDocType='registerFilesIop.message.ComplexMessage' targetDocType='registerFilesIop.message.ComplexMessage' create='new' language='objectscript' > <assign value='source.{post}' property='target.{post}' action='set' /> <foreach property='source.{list_str()}' key='k1' > <assign value='source.{list_str(k1)}_\"foo\"' property='target.{list_str()}' action='append' /> </foreach> <foreach property='source.{list_post()}' key='k2' > <assign value='source.{list_post().Title}' property='target.{list_post(k2).Title}' action='append' /> </foreach> </transform> } }","title":"DTL Support"},{"location":"dtl/#dtl-support","text":"Starting with version 3.2.0, IoP supports DTL transformations. DTL the Data Transformation Layer in IRIS Interoperability. DTL transformations are used to transform data from one format to another with a graphical editor. It supports also jsonschema structures.","title":"DTL Support"},{"location":"dtl/#how-to-use-dtl-in-with-message","text":"First you need to register you message class is a settings.py file. To do so, you need to add the following line in the settings.py file: settings.py from msg import MyMessage SCHEMAS = [MyMessage] Then you can use iop migration command to generate schema files for your message classes. iop --migrate /path/to/your/project/settings.py","title":"How to use DTL in with Message"},{"location":"dtl/#example","text":"msg.py from iop import Message from dataclasses import dataclass @dataclass class MyMessage(Message): name: str = None age: int = None settings.py from msg import MyMessage SCHEMAS = [MyMessage] Migrate the schema files iop --migrate /path/to/your/project/settings.py","title":"Example"},{"location":"dtl/#building-a-dtl-transformation","text":"To build a DTL transformation, you need to create a new DTL transformation class. Go to the IRIS Interoperability Management Portal and create a new DTL transformation. Then select the source and target message classes. And it's schema. Then you can start building your transformation. You can even test your transformation. Example of payload to test as a source message: <test> <Message> <json><![CDATA[ { \"list_str\":[\"toto\",\"titi\"], \"post\":{\"Title\":\"foo\",\"Selftext\":\"baz\"}, \"list_post\":[{\"Title\":\"bar\",\"Selftext\":\"baz\"},{\"Title\":\"foo\",\"Selftext\":\"foo\"}] } ]]></json> </Message> </test>","title":"Building a DTL Transformation"},{"location":"dtl/#jsonschema-support","text":"Starting with version 3.2.0, IoP supports jsonschema structures for DTL transformations. Same as for message classes, you need to register your jsonschema . To do so, you need to invoke his iris command: zw ##class(IOP.Message.JSONSchema).ImportFromFile(\"/irisdev/app/random_jsonschema.json\",\"Demo\",\"Demo\") Where the first argument is the path to the jsonschema file, the second argument is the package name and the third argument is the name of the schema. Then you can use it in your DTL transformation. The schema will be available in the name of Demo . Example jsonschema file: { \"$schema\": \"https://json-schema.org/draft/2020-12/schema\", \"type\": \"object\", \"title\": \"PostMessage\", \"properties\": { \"post\": { \"allOf\": [ { \"$ref\": \"#/$defs/PostClass\" } ] }, \"to_email_address\": { \"type\": \"string\", \"default\": null }, \"my_list\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } }, \"found\": { \"type\": \"string\", \"default\": null }, \"list_of_post\": { \"type\": \"array\", \"items\": { \"allOf\": [ { \"$ref\": \"#/$defs/PostClass\" } ] } } }, \"$defs\": { \"PostClass\": { \"type\": \"object\", \"title\": \"PostClass\", \"properties\": { \"title\": { \"type\": \"string\" }, \"selftext\": { \"type\": \"string\" }, \"author\": { \"type\": \"string\" }, \"url\": { \"type\": \"string\" }, \"created_utc\": { \"type\": \"number\" }, \"original_json\": { \"type\": \"string\", \"default\": null } }, \"required\": [ \"title\", \"selftext\", \"author\", \"url\", \"created_utc\" ] } } }","title":"JsonSchema Support"},{"location":"dtl/#example-of-dtl-transformation-with-jsonschema-or-message-class","text":"Many can be found in the UnitTest package ./src/tests/cls directory. Class UnitTest.ComplexTransform Extends Ens.DataTransformDTL [ DependsOn = IOP.Message ] { Parameter IGNOREMISSINGSOURCE = 1; Parameter REPORTERRORS = 1; Parameter TREATEMPTYREPEATINGFIELDASNULL = 0; XData DTL [ XMLNamespace = \"http://www.intersystems.com/dtl\" ] { <transform sourceClass='IOP.Message' targetClass='IOP.Message' sourceDocType='registerFilesIop.message.ComplexMessage' targetDocType='registerFilesIop.message.ComplexMessage' create='new' language='objectscript' > <assign value='source.{post}' property='target.{post}' action='set' /> <foreach property='source.{list_str()}' key='k1' > <assign value='source.{list_str(k1)}_\"foo\"' property='target.{list_str()}' action='append' /> </foreach> <foreach property='source.{list_post()}' key='k2' > <assign value='source.{list_post().Title}' property='target.{list_post(k2).Title}' action='append' /> </foreach> </transform> } }","title":"Example of DTL Transformation with JsonSchema or Message Class"},{"location":"example/","text":"Example This document provides an example of a business operation and messages in Python, along with instructions on how to register a component. Business Operation Below is an example of a business operation in Python: from iop import BusinessOperation, Message from dataclasses import dataclass class MyBusinessOperation(BusinessOperation): def on_init(self): # This method is called when the component is becoming active in the production self.log_info(\"[Python] MyBusinessOperation:on_init() is called\") return def on_teardown(self): # This method is called when the component is becoming inactive in the production self.log_info(\"[Python] MyBusinessOperation:on_teardown() is called\") return def on_message(self, message_input: 'MyRequest'): # Called from service/process/operation, message is of type MyRequest with property request_string self.log_info(\"[Python] MyBusinessOperation:on_message() is called with message: \" + message_input.request_string) response = MyResponse(\"MyBusinessOperation:on_message() echos\") return response @dataclass class MyRequest(Message): request_string: str = None @dataclass class MyResponse(Message): my_string: str = None Explanation on_init : This method is called when the component becomes active in the production. on_teardown : This method is called when the component becomes inactive in the production. on_message : This method is called from service/process/operation, and it processes the incoming message of type MyRequest . Register a Component To register a component, create a setting.py file in the root of your project. This file will be used to register your classes and productions. Example of setting.py import bo CLASSES = { \"Python.MyBusinessOperation\": bo.MyBusinessOperation } Registering the Component Use the iop command line to register your component: iop --migrate /path/to/your/project/setting.py Business Service Two kinds of business services can be created in Python: Business Service Pulling Business Service Business Service To create a business service, use the following code: from iop import BusinessService class MyBusinessService(BusinessService): def on_process_input(self, message_input: 'MyRequest'): # This method is called when the service is called self.log_info(\"[Python] MyBusinessService:on_process_input() is called with message: \" + message_input.request_string) response = MyResponse(\"MyBusinessService:on_process_input() echos\") return response Pulling Business Service To create a business service that runs every 5 seconds, use the following code: from iop import BusinessService class MyBusinessService(BusinessService): def get_adapter_type(): # This is mandatory to schedule the service # By default, the service will be scheduled every 5 seconds return \"Ens.InboundAdapter\" def on_process_input(self): # This method is called every 5 seconds self.log_info(\"[Python] MyBusinessService:on_process_input() is called\") Flask app sending a message to an Business Service To send a message to a business service, use the following code: from flask import Flask, request from iop import Director app = Flask(__name__) director = Director() @app.route('/send_message', methods=['POST']) def send_message(): message = request.json bs = director.get_business_service(\"Python.MyBusinessService\") resp = bs.on_process_input(message) return resp Business Process To create a business process, use the following code: from iop import BusinessProcess class MyBusinessProcess(BusinessProcess): def on_message(self, message_input: 'MyRequest'): # Called from service/process/operation, message is of type MyRequest with property request_string self.log_info(\"[Python] MyBusinessProcess:on_message() is called with message: \" + message_input.request_string) response = MyResponse(\"MyBusinessProcess:on_message() echos\") return response Async calls There is three ways to make async calls in Python: Using the asyncio library. Using the native send_request_async method. Using the send_multi_request_sync method. Using the asyncio library To make an async call with asyncio, use the following code: import asyncio import random from iop import BusinessProcess from msg import MyMessage class MyAsyncNGBP(BusinessProcess): def on_message(self, request): results = asyncio.run(self.await_response(request)) for result in results: self.log_info(f\"Received response: {result.message}\") async def await_response(self, request): # create 1 to 10 messages tasks = [] for i in range(random.randint(1, 10)): tasks.append(self.send_request_async_ng(\"Python.MyAsyncNGBO\", MyMessage(message=f\"Message {i}\"))) return await asyncio.gather(*tasks) Using the native send_request_async method To make an async call with the native send_request_async method, use the following code: from grongier.pex import BusinessProcess from msg import MyMessage class MyBP(BusinessProcess): def on_message(self, request): msg_one = MyMessage(message=\"Message1\") msg_two = MyMessage(message=\"Message2\") self.send_request_async(\"Python.MyBO\", msg_one,completion_key=\"1\") self.send_request_async(\"Python.MyBO\", msg_two,completion_key=\"2\") def on_response(self, request, response, call_request, call_response, completion_key): if completion_key == \"1\": self.response_one = call_response elif completion_key == \"2\": self.response_two = call_response def on_complete(self, request, response): self.log_info(f\"Received response one: {self.response_one.message}\") self.log_info(f\"Received response two: {self.response_two.message}\") Using the send_multi_request_sync method To make an async call with the send_multi_request_sync method, use the following code: from iop import BusinessProcess from msg import MyMessage class MyMultiBP(BusinessProcess): def on_message(self, request): msg_one = MyMessage(message=\"Message1\") msg_two = MyMessage(message=\"Message2\") tuple_responses = self.send_multi_request_sync([(\"Python.MyMultiBO\", msg_one), (\"Python.MyMultiBO\", msg_two)]) self.log_info(\"All requests have been processed\") for target,request,response,status in tuple_responses: self.log_info(f\"Received response: {response.message}\")","title":"Examples"},{"location":"example/#example","text":"This document provides an example of a business operation and messages in Python, along with instructions on how to register a component.","title":"Example"},{"location":"example/#business-operation","text":"Below is an example of a business operation in Python: from iop import BusinessOperation, Message from dataclasses import dataclass class MyBusinessOperation(BusinessOperation): def on_init(self): # This method is called when the component is becoming active in the production self.log_info(\"[Python] MyBusinessOperation:on_init() is called\") return def on_teardown(self): # This method is called when the component is becoming inactive in the production self.log_info(\"[Python] MyBusinessOperation:on_teardown() is called\") return def on_message(self, message_input: 'MyRequest'): # Called from service/process/operation, message is of type MyRequest with property request_string self.log_info(\"[Python] MyBusinessOperation:on_message() is called with message: \" + message_input.request_string) response = MyResponse(\"MyBusinessOperation:on_message() echos\") return response @dataclass class MyRequest(Message): request_string: str = None @dataclass class MyResponse(Message): my_string: str = None","title":"Business Operation"},{"location":"example/#explanation","text":"on_init : This method is called when the component becomes active in the production. on_teardown : This method is called when the component becomes inactive in the production. on_message : This method is called from service/process/operation, and it processes the incoming message of type MyRequest .","title":"Explanation"},{"location":"example/#register-a-component","text":"To register a component, create a setting.py file in the root of your project. This file will be used to register your classes and productions.","title":"Register a Component"},{"location":"example/#example-of-settingpy","text":"import bo CLASSES = { \"Python.MyBusinessOperation\": bo.MyBusinessOperation }","title":"Example of setting.py"},{"location":"example/#registering-the-component","text":"Use the iop command line to register your component: iop --migrate /path/to/your/project/setting.py","title":"Registering the Component"},{"location":"example/#business-service","text":"Two kinds of business services can be created in Python: Business Service Pulling Business Service","title":"Business Service"},{"location":"example/#business-service_1","text":"To create a business service, use the following code: from iop import BusinessService class MyBusinessService(BusinessService): def on_process_input(self, message_input: 'MyRequest'): # This method is called when the service is called self.log_info(\"[Python] MyBusinessService:on_process_input() is called with message: \" + message_input.request_string) response = MyResponse(\"MyBusinessService:on_process_input() echos\") return response","title":"Business Service"},{"location":"example/#pulling-business-service","text":"To create a business service that runs every 5 seconds, use the following code: from iop import BusinessService class MyBusinessService(BusinessService): def get_adapter_type(): # This is mandatory to schedule the service # By default, the service will be scheduled every 5 seconds return \"Ens.InboundAdapter\" def on_process_input(self): # This method is called every 5 seconds self.log_info(\"[Python] MyBusinessService:on_process_input() is called\")","title":"Pulling Business Service"},{"location":"example/#flask-app-sending-a-message-to-an-business-service","text":"To send a message to a business service, use the following code: from flask import Flask, request from iop import Director app = Flask(__name__) director = Director() @app.route('/send_message', methods=['POST']) def send_message(): message = request.json bs = director.get_business_service(\"Python.MyBusinessService\") resp = bs.on_process_input(message) return resp","title":"Flask app sending a message to an Business Service"},{"location":"example/#business-process","text":"To create a business process, use the following code: from iop import BusinessProcess class MyBusinessProcess(BusinessProcess): def on_message(self, message_input: 'MyRequest'): # Called from service/process/operation, message is of type MyRequest with property request_string self.log_info(\"[Python] MyBusinessProcess:on_message() is called with message: \" + message_input.request_string) response = MyResponse(\"MyBusinessProcess:on_message() echos\") return response","title":"Business Process"},{"location":"example/#async-calls","text":"There is three ways to make async calls in Python: Using the asyncio library. Using the native send_request_async method. Using the send_multi_request_sync method.","title":"Async calls"},{"location":"example/#using-the-asyncio-library","text":"To make an async call with asyncio, use the following code: import asyncio import random from iop import BusinessProcess from msg import MyMessage class MyAsyncNGBP(BusinessProcess): def on_message(self, request): results = asyncio.run(self.await_response(request)) for result in results: self.log_info(f\"Received response: {result.message}\") async def await_response(self, request): # create 1 to 10 messages tasks = [] for i in range(random.randint(1, 10)): tasks.append(self.send_request_async_ng(\"Python.MyAsyncNGBO\", MyMessage(message=f\"Message {i}\"))) return await asyncio.gather(*tasks)","title":"Using the asyncio library"},{"location":"example/#using-the-native-send_request_async-method","text":"To make an async call with the native send_request_async method, use the following code: from grongier.pex import BusinessProcess from msg import MyMessage class MyBP(BusinessProcess): def on_message(self, request): msg_one = MyMessage(message=\"Message1\") msg_two = MyMessage(message=\"Message2\") self.send_request_async(\"Python.MyBO\", msg_one,completion_key=\"1\") self.send_request_async(\"Python.MyBO\", msg_two,completion_key=\"2\") def on_response(self, request, response, call_request, call_response, completion_key): if completion_key == \"1\": self.response_one = call_response elif completion_key == \"2\": self.response_two = call_response def on_complete(self, request, response): self.log_info(f\"Received response one: {self.response_one.message}\") self.log_info(f\"Received response two: {self.response_two.message}\")","title":"Using the native send_request_async method"},{"location":"example/#using-the-send_multi_request_sync-method","text":"To make an async call with the send_multi_request_sync method, use the following code: from iop import BusinessProcess from msg import MyMessage class MyMultiBP(BusinessProcess): def on_message(self, request): msg_one = MyMessage(message=\"Message1\") msg_two = MyMessage(message=\"Message2\") tuple_responses = self.send_multi_request_sync([(\"Python.MyMultiBO\", msg_one), (\"Python.MyMultiBO\", msg_two)]) self.log_info(\"All requests have been processed\") for target,request,response,status in tuple_responses: self.log_info(f\"Received response: {response.message}\")","title":"Using the send_multi_request_sync method"},{"location":"logging/","text":"Logging InterSystems IRIS Interoperability framework implements its own logging system. The Python API provides a way to use Python's logging module integrated with IRIS logging. Basic Usage The logging system is available through the component base class. You can access it via the logger property or use the convenience methods: def on_init(self): # Using convenience methods self.log_info(\"Component initialized\") self.log_error(\"An error occurred\") self.log_warning(\"Warning message\") self.log_alert(\"Critical alert\") self.trace(\"Debug trace message\") # Using logger property self.logger.info(\"Info via logger\") self.logger.error(\"Error via logger\") Console Logging You can direct logs to the console instead of IRIS in two ways: Set the component-wide setting: def on_init(self): self.log_to_console = True self.log_info(\"This will go to console\") Per-message console logging: def on_message(self, request): # Log specific message to console self.log_info(\"Debug info\", to_console=True) # Other logs still go to IRIS self.log_info(\"Production info\") Log Levels The following log levels are available: trace() - Debug level logging (maps to IRIS LogTrace) log_info() - Information messages (maps to IRIS LogInfo) log_warning() - Warning messages (maps to IRIS LogWarning) log_error() - Error messages (maps to IRIS LogError) log_alert() - Critical/Alert messages (maps to IRIS LogAlert) log_assert() - Assert messages (maps to IRIS LogAssert) Integration with IRIS The Python logging is automatically mapped to the appropriate IRIS logging methods: Python DEBUG \u2192 IRIS LogTrace Python INFO \u2192 IRIS LogInfo Python WARNING \u2192 IRIS LogWarning Python ERROR \u2192 IRIS LogError Python CRITICAL \u2192 IRIS LogAlert Legacy Methods The following methods are deprecated but maintained for backwards compatibility: LOGINFO() - Use log_info() instead LOGALERT() - Use log_alert() instead LOGWARNING() - Use log_warning() instead LOGERROR() - Use log_error() instead LOGASSERT() - Use log_assert() instead","title":"Logging"},{"location":"logging/#logging","text":"InterSystems IRIS Interoperability framework implements its own logging system. The Python API provides a way to use Python's logging module integrated with IRIS logging.","title":"Logging"},{"location":"logging/#basic-usage","text":"The logging system is available through the component base class. You can access it via the logger property or use the convenience methods: def on_init(self): # Using convenience methods self.log_info(\"Component initialized\") self.log_error(\"An error occurred\") self.log_warning(\"Warning message\") self.log_alert(\"Critical alert\") self.trace(\"Debug trace message\") # Using logger property self.logger.info(\"Info via logger\") self.logger.error(\"Error via logger\")","title":"Basic Usage"},{"location":"logging/#console-logging","text":"You can direct logs to the console instead of IRIS in two ways: Set the component-wide setting: def on_init(self): self.log_to_console = True self.log_info(\"This will go to console\") Per-message console logging: def on_message(self, request): # Log specific message to console self.log_info(\"Debug info\", to_console=True) # Other logs still go to IRIS self.log_info(\"Production info\")","title":"Console Logging"},{"location":"logging/#log-levels","text":"The following log levels are available: trace() - Debug level logging (maps to IRIS LogTrace) log_info() - Information messages (maps to IRIS LogInfo) log_warning() - Warning messages (maps to IRIS LogWarning) log_error() - Error messages (maps to IRIS LogError) log_alert() - Critical/Alert messages (maps to IRIS LogAlert) log_assert() - Assert messages (maps to IRIS LogAssert)","title":"Log Levels"},{"location":"logging/#integration-with-iris","text":"The Python logging is automatically mapped to the appropriate IRIS logging methods: Python DEBUG \u2192 IRIS LogTrace Python INFO \u2192 IRIS LogInfo Python WARNING \u2192 IRIS LogWarning Python ERROR \u2192 IRIS LogError Python CRITICAL \u2192 IRIS LogAlert","title":"Integration with IRIS"},{"location":"logging/#legacy-methods","text":"The following methods are deprecated but maintained for backwards compatibility: LOGINFO() - Use log_info() instead LOGALERT() - Use log_alert() instead LOGWARNING() - Use log_warning() instead LOGERROR() - Use log_error() instead LOGASSERT() - Use log_assert() instead","title":"Legacy Methods"},{"location":"prod-settings/","text":"Settings in production To pass production settings to your component, you have two options: Use the %settings parameter Create your custom settings Context In production when you select a component, you can configure it by passing settings. Those settings can be passed to your python code. Use the %settings parameter All the settings passed to %settings are available in string format into your class as a root attribute. Each line of the %settings parameter is a key-value pair separated by a the equal sign. Key will be the name of the attribute and value will be the value of the attribute. For example, if you have the following settings: foo=bar my_number=42 You can access those settings in your class like this: from iop import BusinessOperation class MyBusinessOperation(BusinessOperation): def on_init(self): self.log_info(\"[Python] MyBusinessOperation:on_init() is called\") self.log_info(\"[Python] foo: \" + self.foo) self.log_info(\"[Python] my_number: \" + self.my_number) return As %settings is a free text field, you can pass any settings you want. Meaning you should verify if the attribute exists before using it. from iop import BusinessOperation class MyBusinessOperation(BusinessOperation): def on_init(self): self.log_info(\"[Python] MyBusinessOperation:on_init() is called\") if hasattr(self, 'foo'): self.log_info(\"[Python] foo: \" + self.foo) if hasattr(self, 'my_number'): self.log_info(\"[Python] my_number: \" + self.my_number) return Create your custom settings If you want to have a more structured way to pass settings, you can create your custom settings. To create a custom settings, you create an attribute in your class. This attribute must : have an default value. don't start with an underscore. be untyped or have the following types: str , int , float , bool . Otherwise, it will not be available in the managment portal. from iop import BusinessOperation class MyBusinessOperation(BusinessOperation): # This setting will be available in the managment portal foo: str = \"default\" my_number: int = 42 untyped_setting = None # This setting will not be available in the managment portal _my_internal_setting: str = \"default\" no_aviable_setting def on_init(self): self.log_info(\"[Python] MyBusinessOperation:on_init() is called\") self.log_info(\"[Python] foo: \" + self.foo) self.log_info(\"[Python] my_number: \" + str(self.my_number)) return They will be available in the managment portal as the following: If you overwrite the default value in the managment portal, the new value will be passed to your class.","title":"Production Settings"},{"location":"prod-settings/#settings-in-production","text":"To pass production settings to your component, you have two options: Use the %settings parameter Create your custom settings","title":"Settings in production"},{"location":"prod-settings/#context","text":"In production when you select a component, you can configure it by passing settings. Those settings can be passed to your python code.","title":"Context"},{"location":"prod-settings/#use-the-settings-parameter","text":"All the settings passed to %settings are available in string format into your class as a root attribute. Each line of the %settings parameter is a key-value pair separated by a the equal sign. Key will be the name of the attribute and value will be the value of the attribute. For example, if you have the following settings: foo=bar my_number=42 You can access those settings in your class like this: from iop import BusinessOperation class MyBusinessOperation(BusinessOperation): def on_init(self): self.log_info(\"[Python] MyBusinessOperation:on_init() is called\") self.log_info(\"[Python] foo: \" + self.foo) self.log_info(\"[Python] my_number: \" + self.my_number) return As %settings is a free text field, you can pass any settings you want. Meaning you should verify if the attribute exists before using it. from iop import BusinessOperation class MyBusinessOperation(BusinessOperation): def on_init(self): self.log_info(\"[Python] MyBusinessOperation:on_init() is called\") if hasattr(self, 'foo'): self.log_info(\"[Python] foo: \" + self.foo) if hasattr(self, 'my_number'): self.log_info(\"[Python] my_number: \" + self.my_number) return","title":"Use the %settings parameter"},{"location":"prod-settings/#create-your-custom-settings","text":"If you want to have a more structured way to pass settings, you can create your custom settings. To create a custom settings, you create an attribute in your class. This attribute must : have an default value. don't start with an underscore. be untyped or have the following types: str , int , float , bool . Otherwise, it will not be available in the managment portal. from iop import BusinessOperation class MyBusinessOperation(BusinessOperation): # This setting will be available in the managment portal foo: str = \"default\" my_number: int = 42 untyped_setting = None # This setting will not be available in the managment portal _my_internal_setting: str = \"default\" no_aviable_setting def on_init(self): self.log_info(\"[Python] MyBusinessOperation:on_init() is called\") self.log_info(\"[Python] foo: \" + self.foo) self.log_info(\"[Python] my_number: \" + str(self.my_number)) return They will be available in the managment portal as the following: If you overwrite the default value in the managment portal, the new value will be passed to your class.","title":"Create your custom settings"},{"location":"python-api/","text":"Python API Documentation Core Classes Message \ud83d\udce6 Base class for messages passed between components. This class provides the foundation for all message types in the interoperability framework. Usage: Subclass Message and decorate with @dataclass to define message properties. This approach provides type hints and automatic initialization. Example: from iop import Message from dataclasses import dataclass @dataclass class MyRequest(Message): request_string: str = None PydanticMessage \ud83d\udce6 Base class for messages that use Pydantic models for validation and serialization. This class provides additional features for data validation and serialization. Usage: Subclass PydanticMessage and define a Pydantic model as a class attribute. This approach provides automatic validation and serialization. Example: from iop import PydanticMessage class MyRequest(PydanticMessage): model : str = None BusinessService \ud83d\udd04 Base class for business services that receive and process incoming data. Business services act as entry points for data into your interoperability solution. Key Methods: on_process_input(self, message_input: Message) -> None Handles incoming messages from adapter Parameters: message_input : The incoming message to process Returns: None send_request_sync(self, target: str, request: Message, timeout: int = -1) -> Message Sends a synchronous request and waits for response Parameters: target : Name of the target component request : Message to send timeout : Maximum wait time in seconds (-1 for default) Returns: Response message send_request_async(self, target: str, request: Message) -> None Sends an asynchronous request without waiting Parameters: target : Name of the target component request : Message to send Returns: None Basic Example: from iop import BusinessService class MyService(BusinessService): def on_process_input(self, message_input): self.log_info(f\"Received: {message_input}\") Advanced Example with Adapter: from iop import BusinessService, Message from dataclasses import dataclass @dataclass class MyRequest(Message): file_path: str = None data: str = None class MyService(BusinessService): def get_adapter_type(): \"\"\"Enable pull mode for the BusinessService\"\"\" return \"Ens.InboundAdapter\" def on_process_input(self, message_input): self.log_info(f\"Received: {message_input}\") with open(message_input.file_path, 'r') as file: data = file.read() request = MyRequest(data=data) self.send_request_async(\"MyBusinessOperation\", request) BusinessOperation \ud83d\udd27 Base class for business operations that process requests and perform specific business logic. Key Methods: on_message(self, request: Message) -> Message Process incoming request messages Parameters: request : The incoming message to process Returns: Response message send_request_sync(self, target: str, request: Message, timeout: int = -1) -> Message Send synchronous request and wait for response Parameters and returns same as BusinessService send_request_async(self, target: str, request: Message) -> None Send asynchronous request without waiting Parameters and returns same as BusinessService Example: from iop import BusinessOperation, Message from dataclasses import dataclass @dataclass class MyRequest(Message): request_string: str = None @dataclass class MyResponse(Message): my_string: str = None class MyOperation(BusinessOperation): def on_message(self, request): self.log_info(f\"Received: {request}\") return MyResponse(my_string=\"Hello World\") BusinessProcess \u200d\ud83d\udcbc Base class for business processes that orchestrate message flow between components. Key Methods: on_request(self, request: Message) -> None Handle initial incoming requests Parameters: request : The incoming request to process Returns: None on_response(self, request: Message, response: Message, call_request: Message, call_response: Message, completion_key: str) -> None Handle asynchronous responses Parameters: request : Original request response : Current response call_request : Request that generated this response call_response : The response being processed completion_key : Unique identifier for the response chain Returns: None on_complete(self, request: Message, response: Message) -> None Called after all responses are received Parameters: request : Original request response : Final response Returns: None reply(self, response: Message) -> None Send response back to the caller Parameters: response : Response message to send Returns: None Example: from iop import BusinessProcess, Message from dataclasses import dataclass @dataclass class MyRequest(Message): request_string: str = None @dataclass class MyResponse(Message): my_string: str = None class MyProcess(BusinessProcess): def on_request(self, request): self.log_info(f\"Received: {request}\") self.send_request_async(\"MyBusinessOperation\", request) def on_response(self, request, response, call_request, call_response, completion_key): self.log_info(f\"Received: {response}\") self.reply(response) Adapter Classes \ud83d\udd0c InboundAdapter Base class for adapters that receive external data. Key Methods: on_task(self) -> None Called at configured intervals to check for new data Override this method to implement custom data acquisition logic Returns: None OutboundAdapter Base class for adapters that send data to external systems. Key Methods: on_keepalive(self) -> None Called periodically to maintain external connections Implement connection maintenance logic here Returns: None Common Methods \ud83d\udee0\ufe0f Available in all component classes: Logging Methods: log_info(self, message: str) -> None Log informational message for general information log_error(self, message: str) -> None Log error message for errors and exceptions log_warning(self, message: str) -> None Log warning message for potential issues log_alert(self, message: str) -> None Log alert message for critical situations Lifecycle Methods: on_init(self) -> None Initialize component when it starts Override to add custom initialization on_tear_down(self) -> None Clean up resources when component stops Override to add custom cleanup logic on_connected(self) -> None Handle connection setup when connections are established Override to add custom connection logic Director Class \ud83c\udfad Manages InterSystems IRIS productions and business services, particularly for non-polling services. Key Methods: Production Management: start_production(production_name: str = None) -> None Start a production If no name provided, uses default production stop_production() -> None Stop the currently running production restart_production() -> None Restart the current production shutdown_production() -> None Gracefully shutdown the production status_production() -> dict Get current production status Returns dictionary with production details Business Service Management: create_business_service(target: str) -> object Create an instance of a business service Parameters: target : Name of the business service in production Returns: Business service instance get_business_service(target: str) -> object Get an existing business service instance Parameters: target : Name of the business service in production Returns: Business service instance test_component(target: str, message=None, classname: str=None, body=None) -> object Test a production component Parameters: target : Component name message : Optional message instance classname : Optional message class name body : Optional message body Returns: Component response Production Logging: log_production() -> None Start real-time production log monitoring Press Ctrl+C to stop log_production_top(top: int) -> None Display last N log entries Parameters: top : Number of entries to show Production Configuration: set_default_production(production_name: str) -> None Set the default production name get_default_production() -> str Get the current default production name Example Usage: In a flask application : from iop import Director from flask import Flask app = Flask(__name__) director = Director() @app.route('/') def hello_world(): bs = director.get_business_service(\"MyBusinessService\") return bs.on_process_input(\"Hello, World!\")","title":"Python API"},{"location":"python-api/#python-api-documentation","text":"","title":"Python API Documentation"},{"location":"python-api/#core-classes","text":"","title":"Core Classes"},{"location":"python-api/#message","text":"Base class for messages passed between components. This class provides the foundation for all message types in the interoperability framework. Usage: Subclass Message and decorate with @dataclass to define message properties. This approach provides type hints and automatic initialization. Example: from iop import Message from dataclasses import dataclass @dataclass class MyRequest(Message): request_string: str = None","title":"Message \ud83d\udce6"},{"location":"python-api/#pydanticmessage","text":"Base class for messages that use Pydantic models for validation and serialization. This class provides additional features for data validation and serialization. Usage: Subclass PydanticMessage and define a Pydantic model as a class attribute. This approach provides automatic validation and serialization. Example: from iop import PydanticMessage class MyRequest(PydanticMessage): model : str = None","title":"PydanticMessage \ud83d\udce6"},{"location":"python-api/#businessservice","text":"Base class for business services that receive and process incoming data. Business services act as entry points for data into your interoperability solution. Key Methods: on_process_input(self, message_input: Message) -> None Handles incoming messages from adapter Parameters: message_input : The incoming message to process Returns: None send_request_sync(self, target: str, request: Message, timeout: int = -1) -> Message Sends a synchronous request and waits for response Parameters: target : Name of the target component request : Message to send timeout : Maximum wait time in seconds (-1 for default) Returns: Response message send_request_async(self, target: str, request: Message) -> None Sends an asynchronous request without waiting Parameters: target : Name of the target component request : Message to send Returns: None Basic Example: from iop import BusinessService class MyService(BusinessService): def on_process_input(self, message_input): self.log_info(f\"Received: {message_input}\") Advanced Example with Adapter: from iop import BusinessService, Message from dataclasses import dataclass @dataclass class MyRequest(Message): file_path: str = None data: str = None class MyService(BusinessService): def get_adapter_type(): \"\"\"Enable pull mode for the BusinessService\"\"\" return \"Ens.InboundAdapter\" def on_process_input(self, message_input): self.log_info(f\"Received: {message_input}\") with open(message_input.file_path, 'r') as file: data = file.read() request = MyRequest(data=data) self.send_request_async(\"MyBusinessOperation\", request)","title":"BusinessService \ud83d\udd04"},{"location":"python-api/#businessoperation","text":"Base class for business operations that process requests and perform specific business logic. Key Methods: on_message(self, request: Message) -> Message Process incoming request messages Parameters: request : The incoming message to process Returns: Response message send_request_sync(self, target: str, request: Message, timeout: int = -1) -> Message Send synchronous request and wait for response Parameters and returns same as BusinessService send_request_async(self, target: str, request: Message) -> None Send asynchronous request without waiting Parameters and returns same as BusinessService Example: from iop import BusinessOperation, Message from dataclasses import dataclass @dataclass class MyRequest(Message): request_string: str = None @dataclass class MyResponse(Message): my_string: str = None class MyOperation(BusinessOperation): def on_message(self, request): self.log_info(f\"Received: {request}\") return MyResponse(my_string=\"Hello World\")","title":"BusinessOperation \ud83d\udd27"},{"location":"python-api/#businessprocess","text":"Base class for business processes that orchestrate message flow between components. Key Methods: on_request(self, request: Message) -> None Handle initial incoming requests Parameters: request : The incoming request to process Returns: None on_response(self, request: Message, response: Message, call_request: Message, call_response: Message, completion_key: str) -> None Handle asynchronous responses Parameters: request : Original request response : Current response call_request : Request that generated this response call_response : The response being processed completion_key : Unique identifier for the response chain Returns: None on_complete(self, request: Message, response: Message) -> None Called after all responses are received Parameters: request : Original request response : Final response Returns: None reply(self, response: Message) -> None Send response back to the caller Parameters: response : Response message to send Returns: None Example: from iop import BusinessProcess, Message from dataclasses import dataclass @dataclass class MyRequest(Message): request_string: str = None @dataclass class MyResponse(Message): my_string: str = None class MyProcess(BusinessProcess): def on_request(self, request): self.log_info(f\"Received: {request}\") self.send_request_async(\"MyBusinessOperation\", request) def on_response(self, request, response, call_request, call_response, completion_key): self.log_info(f\"Received: {response}\") self.reply(response)","title":"BusinessProcess \u200d\ud83d\udcbc"},{"location":"python-api/#adapter-classes","text":"","title":"Adapter Classes \ud83d\udd0c"},{"location":"python-api/#inboundadapter","text":"Base class for adapters that receive external data. Key Methods: on_task(self) -> None Called at configured intervals to check for new data Override this method to implement custom data acquisition logic Returns: None","title":"InboundAdapter"},{"location":"python-api/#outboundadapter","text":"Base class for adapters that send data to external systems. Key Methods: on_keepalive(self) -> None Called periodically to maintain external connections Implement connection maintenance logic here Returns: None","title":"OutboundAdapter"},{"location":"python-api/#common-methods","text":"Available in all component classes: Logging Methods: log_info(self, message: str) -> None Log informational message for general information log_error(self, message: str) -> None Log error message for errors and exceptions log_warning(self, message: str) -> None Log warning message for potential issues log_alert(self, message: str) -> None Log alert message for critical situations Lifecycle Methods: on_init(self) -> None Initialize component when it starts Override to add custom initialization on_tear_down(self) -> None Clean up resources when component stops Override to add custom cleanup logic on_connected(self) -> None Handle connection setup when connections are established Override to add custom connection logic","title":"Common Methods \ud83d\udee0\ufe0f"},{"location":"python-api/#director-class","text":"Manages InterSystems IRIS productions and business services, particularly for non-polling services. Key Methods: Production Management: start_production(production_name: str = None) -> None Start a production If no name provided, uses default production stop_production() -> None Stop the currently running production restart_production() -> None Restart the current production shutdown_production() -> None Gracefully shutdown the production status_production() -> dict Get current production status Returns dictionary with production details Business Service Management: create_business_service(target: str) -> object Create an instance of a business service Parameters: target : Name of the business service in production Returns: Business service instance get_business_service(target: str) -> object Get an existing business service instance Parameters: target : Name of the business service in production Returns: Business service instance test_component(target: str, message=None, classname: str=None, body=None) -> object Test a production component Parameters: target : Component name message : Optional message instance classname : Optional message class name body : Optional message body Returns: Component response Production Logging: log_production() -> None Start real-time production log monitoring Press Ctrl+C to stop log_production_top(top: int) -> None Display last N log entries Parameters: top : Number of entries to show Production Configuration: set_default_production(production_name: str) -> None Set the default production name get_default_production() -> str Get the current default production name Example Usage: In a flask application : from iop import Director from flask import Flask app = Flask(__name__) director = Director() @app.route('/') def hello_world(): bs = director.get_business_service(\"MyBusinessService\") return bs.on_process_input(\"Hello, World!\")","title":"Director Class \ud83c\udfad"},{"location":"useful-links/","text":"Useful Links Explore the following resources to learn more about the project and see it in action: Training Training Repository A repository to learn how to use the project. Templates Project Template A template to start a new project. Project Links PyPI The project on PyPI. GitHub The project on GitHub. Demos Flask Demo Demonstrates how to use the project with Flask. FastAPI Demo Demonstrates how to use the project with FastAPI. Django Demo Demonstrates how to use the project with Django. Kafka Demo Example of using the project with Kafka. RAG Demo Example of using the project with RAG. IRIS Chemical Example of extracting chemical properties. Rest to DICOM Example of using the project with RestToDicom. OCR Example of using the project with an OCR engine.","title":"Useful Links"},{"location":"useful-links/#useful-links","text":"Explore the following resources to learn more about the project and see it in action:","title":"Useful Links"},{"location":"useful-links/#training","text":"Training Repository A repository to learn how to use the project.","title":"Training"},{"location":"useful-links/#templates","text":"Project Template A template to start a new project.","title":"Templates"},{"location":"useful-links/#project-links","text":"PyPI The project on PyPI. GitHub The project on GitHub.","title":"Project Links"},{"location":"useful-links/#demos","text":"Flask Demo Demonstrates how to use the project with Flask. FastAPI Demo Demonstrates how to use the project with FastAPI. Django Demo Demonstrates how to use the project with Django. Kafka Demo Example of using the project with Kafka. RAG Demo Example of using the project with RAG. IRIS Chemical Example of extracting chemical properties. Rest to DICOM Example of using the project with RestToDicom. OCR Example of using the project with an OCR engine.","title":"Demos"},{"location":"venv/","text":"venv support How to set up a virtual environment for the Iris IOP framework. ! Note: This is a proof-of-concept and not a production-ready solution. As it's a proof-of-concept, a toggle is available and called %Venv if you want to enable or disable the virtual environment support. How everything is set up The source code are migrated to iris thanks to the iop --migrate command. Both virtual environments are created using the vanilla python -m venv command. The iop command is used to run the source code in the virtual environments. # activate the secondary virtual environment source /opt/irisapp/.venv3.11/bin/activate # migrate the source code iop -m /irisdev/app/src/python/other/settings.py # deactivate the secondary virtual environment deactivate # activate the main virtual environment source /opt/irisapp/.venv/bin/activate # migrate the source code iop -m /irisdev/app/src/python/reddit/settings.py # start production iop --start dc.Python.Production ! Note: if deploying code in a non-venv environment, the parameters %PythonPath won't be set, and the code will run in the default python environment. Virtual Manual configuration The parameters : %PythonPath : the path to the python lib in the virtual environment %PythonRuntimeLibraryVersion : the version of python used in the virtual environment %PythonRuntimeLibrary : the path to the lib python in the virtual environment Full example See the full example in the iris-venv-demo . How it works As the interoperability framework works with independent processes, it's manageable to run each process in its own virtual environment. This allows for easy management of dependencies and versions. For this demo, we will be using two virtual environments: .venv This is the main virtual environment that will run source code in ./src/python/reddit It will use it's own dependencies in ./src/python/reddit/requirements.txt requests dataclasses-json The version of python will be 3.12 The venv folder will be in /opt/irisapp/.venv/ .venv3.11 This is a secondary virtual environment that will run source code in ./src/python/other It will use it's own dependencies in ./src/python/other/requirements.txt deepdiff The version of python will be 3.11 The venv folder will be in /opt/irisapp/.venv3.11/ Screenshots","title":"Venv Support"},{"location":"venv/#venv-support","text":"How to set up a virtual environment for the Iris IOP framework. ! Note: This is a proof-of-concept and not a production-ready solution. As it's a proof-of-concept, a toggle is available and called %Venv if you want to enable or disable the virtual environment support.","title":"venv support"},{"location":"venv/#how-everything-is-set-up","text":"The source code are migrated to iris thanks to the iop --migrate command. Both virtual environments are created using the vanilla python -m venv command. The iop command is used to run the source code in the virtual environments. # activate the secondary virtual environment source /opt/irisapp/.venv3.11/bin/activate # migrate the source code iop -m /irisdev/app/src/python/other/settings.py # deactivate the secondary virtual environment deactivate # activate the main virtual environment source /opt/irisapp/.venv/bin/activate # migrate the source code iop -m /irisdev/app/src/python/reddit/settings.py # start production iop --start dc.Python.Production ! Note: if deploying code in a non-venv environment, the parameters %PythonPath won't be set, and the code will run in the default python environment.","title":"How everything is set up"},{"location":"venv/#virtual-manual-configuration","text":"The parameters : %PythonPath : the path to the python lib in the virtual environment %PythonRuntimeLibraryVersion : the version of python used in the virtual environment %PythonRuntimeLibrary : the path to the lib python in the virtual environment","title":"Virtual Manual configuration"},{"location":"venv/#full-example","text":"See the full example in the iris-venv-demo .","title":"Full example"},{"location":"venv/#how-it-works","text":"As the interoperability framework works with independent processes, it's manageable to run each process in its own virtual environment. This allows for easy management of dependencies and versions. For this demo, we will be using two virtual environments: .venv This is the main virtual environment that will run source code in ./src/python/reddit It will use it's own dependencies in ./src/python/reddit/requirements.txt requests dataclasses-json The version of python will be 3.12 The venv folder will be in /opt/irisapp/.venv/ .venv3.11 This is a secondary virtual environment that will run source code in ./src/python/other It will use it's own dependencies in ./src/python/other/requirements.txt deepdiff The version of python will be 3.11 The venv folder will be in /opt/irisapp/.venv3.11/","title":"How it works"},{"location":"venv/#screenshots","text":"","title":"Screenshots"},{"location":"getting-started/first-steps/","text":"Getting Started with Interoperability On Python Welcome to the guide on getting started with Interoperability Embedded Python. This document will walk you through the initial steps to set up and begin using Python in your interoperability projects. Prerequisites Before you begin, ensure you have the following: A working installation of InterSystems IRIS with Embedded Python configured Basic knowledge of Python programming Setting Up the Virtual Environment To begin, you will need to set up a virtual environment for your Python project. A virtual environment is a self-contained directory that contains a Python installation for a particular version of Python, as well as any additional packages you may need for your project. To create a virtual environment, run the following command in your terminal: python -m venv .venv This will create a new directory called .venv in your project directory, which will contain the Python interpreter and any packages you install. Next, activate the virtual environment by running the following command: For Unix or MacOS: source .venv/bin/activate For Windows: .venv\\Scripts\\activate You should now see the name of your virtual environment in your terminal prompt, indicating that the virtual environment is active. Installing Required Packages With your virtual environment activated, you can now install any required packages for your project. To install a package, use the pip command followed by the package name. For example, to install the iris-pex-embedded-python package, run the following command: pip install iris-pex-embedded-python Init the application using the following command: iop --init This will install the package and any dependencies it requires. Hello World Now that you have set up your virtual environment and installed the required packages, you are ready to create your first Interoperability production using Python. Create a Business Operation For this, we will create an BusinessOperation that will take a message as input and will return a message as output. In between, it will just print \"Hello World\" in the logs. To do this, let's create a new folder named hello_world . mkdir hello_world In this folder, create a new file named bo.py . This file will contain the code of our business operation. from iop import BusinessOperation class MyBo(BusinessOperation): def on_message(self, request): self.log_info(\"Hello World\") Let's explain this code. First, we import the BusinessOperation class from the iop module. Then, we create a class named MyBo that inherits from BusinessOperation . Finally, we override the on_message method. This method will be called when a message is received by the business operation. Import this Business Operation in the framework Now, we need to add this business operation to what we call a production. To do this, we will create a new file in the hello_world folder, named settings.py . Every project starts at it's root folder by a file named settings.py . This file contains two main settings: CLASSES : it contains the classes that will be used in the project. PRODUCTIONS : it contains the name of the production that will be used in the project. from hello_world.bo import MyBo CLASSES = { \"MyIRIS.MyBo\": MyBo } PRODUCTIONS = [ { 'MyIRIS.Production': { \"@TestingEnabled\": \"true\", \"Item\": [ { \"@Name\": \"Instance.Of.MyBo\", \"@ClassName\": \"MyIRIS.MyBo\", } ] } } ] In this file, we import our MyBo class named in iris MyIRIS.MyBo , and we add it to the CLASSES dictionnary. Then, we add a new production to the PRODUCTIONS list. This production will contain our MyBo class instance named Instance.Of.MyBo . With the iop command, we can now create the production in IRIS. iop --migrate /path/to/hello_world/settings.py This command will create the production in IRIS and add the MyBo class to it. More information about registering components can be found here .","title":"First Steps"},{"location":"getting-started/first-steps/#getting-started-with-interoperability-on-python","text":"Welcome to the guide on getting started with Interoperability Embedded Python. This document will walk you through the initial steps to set up and begin using Python in your interoperability projects.","title":"Getting Started with Interoperability On Python"},{"location":"getting-started/first-steps/#prerequisites","text":"Before you begin, ensure you have the following: A working installation of InterSystems IRIS with Embedded Python configured Basic knowledge of Python programming","title":"Prerequisites"},{"location":"getting-started/first-steps/#setting-up-the-virtual-environment","text":"To begin, you will need to set up a virtual environment for your Python project. A virtual environment is a self-contained directory that contains a Python installation for a particular version of Python, as well as any additional packages you may need for your project. To create a virtual environment, run the following command in your terminal: python -m venv .venv This will create a new directory called .venv in your project directory, which will contain the Python interpreter and any packages you install. Next, activate the virtual environment by running the following command: For Unix or MacOS: source .venv/bin/activate For Windows: .venv\\Scripts\\activate You should now see the name of your virtual environment in your terminal prompt, indicating that the virtual environment is active.","title":"Setting Up the Virtual Environment"},{"location":"getting-started/first-steps/#installing-required-packages","text":"With your virtual environment activated, you can now install any required packages for your project. To install a package, use the pip command followed by the package name. For example, to install the iris-pex-embedded-python package, run the following command: pip install iris-pex-embedded-python Init the application using the following command: iop --init This will install the package and any dependencies it requires.","title":"Installing Required Packages"},{"location":"getting-started/first-steps/#hello-world","text":"Now that you have set up your virtual environment and installed the required packages, you are ready to create your first Interoperability production using Python.","title":"Hello World"},{"location":"getting-started/first-steps/#create-a-business-operation","text":"For this, we will create an BusinessOperation that will take a message as input and will return a message as output. In between, it will just print \"Hello World\" in the logs. To do this, let's create a new folder named hello_world . mkdir hello_world In this folder, create a new file named bo.py . This file will contain the code of our business operation. from iop import BusinessOperation class MyBo(BusinessOperation): def on_message(self, request): self.log_info(\"Hello World\") Let's explain this code. First, we import the BusinessOperation class from the iop module. Then, we create a class named MyBo that inherits from BusinessOperation . Finally, we override the on_message method. This method will be called when a message is received by the business operation.","title":"Create a Business Operation"},{"location":"getting-started/first-steps/#import-this-business-operation-in-the-framework","text":"Now, we need to add this business operation to what we call a production. To do this, we will create a new file in the hello_world folder, named settings.py . Every project starts at it's root folder by a file named settings.py . This file contains two main settings: CLASSES : it contains the classes that will be used in the project. PRODUCTIONS : it contains the name of the production that will be used in the project. from hello_world.bo import MyBo CLASSES = { \"MyIRIS.MyBo\": MyBo } PRODUCTIONS = [ { 'MyIRIS.Production': { \"@TestingEnabled\": \"true\", \"Item\": [ { \"@Name\": \"Instance.Of.MyBo\", \"@ClassName\": \"MyIRIS.MyBo\", } ] } } ] In this file, we import our MyBo class named in iris MyIRIS.MyBo , and we add it to the CLASSES dictionnary. Then, we add a new production to the PRODUCTIONS list. This production will contain our MyBo class instance named Instance.Of.MyBo . With the iop command, we can now create the production in IRIS. iop --migrate /path/to/hello_world/settings.py This command will create the production in IRIS and add the MyBo class to it. More information about registering components can be found here .","title":"Import this Business Operation in the framework"},{"location":"getting-started/installation/","text":"Installation Guide Welcome to the installation guide for IoP. This guide will walk you through the steps to install the application on your local machine or in a docker container image. Prerequisites Before you begin, ensure you have the following installed: Python 3.6 or higher IRIS 2021.2 or higher Configuring Embedded Python With PyPi To install the application using PyPi, run the following command: pip install iris-pex-embedded-python Then you can run the application using the following command: iop --init Check the documentation about the command line interface here for more information. With ZPM/IPM To install the application using ZPM or IPM, run the following command: zpm \"install iris-pex-embedded-python\"","title":"Installation"},{"location":"getting-started/installation/#installation-guide","text":"Welcome to the installation guide for IoP. This guide will walk you through the steps to install the application on your local machine or in a docker container image.","title":"Installation Guide"},{"location":"getting-started/installation/#prerequisites","text":"Before you begin, ensure you have the following installed: Python 3.6 or higher IRIS 2021.2 or higher Configuring Embedded Python","title":"Prerequisites"},{"location":"getting-started/installation/#with-pypi","text":"To install the application using PyPi, run the following command: pip install iris-pex-embedded-python Then you can run the application using the following command: iop --init Check the documentation about the command line interface here for more information.","title":"With PyPi"},{"location":"getting-started/installation/#with-zpmipm","text":"To install the application using ZPM or IPM, run the following command: zpm \"install iris-pex-embedded-python\"","title":"With ZPM/IPM"},{"location":"getting-started/register-component/","text":"Registering Components There are two main ways to register your Python components with IRIS Interoperability: With a settings file With a Python script: Register a single component using register_component Register all components in a file using register_file Register all components in a folder using register_folder With a Settings File Create a settings.py file in the root of your project. This file will be used to register your classes and productions. Example of settings.py import bo CLASSES = { \"Python.MyBusinessOperation\": bo.MyBusinessOperation } Registering the Component Use the iop command line to register your component: iop --migrate /path/to/your/project/setting.py Using the Python Shell Registering a Single Component Use the register_component method to add a new Python file to the component list for interoperability. from iop import Utils Utils.register_component(<ModuleName>,<ClassName>,<PathToPyFile>,<OverWrite>,<NameOfTheComponent>) Example: from iop import Utils Utils.register_component(\"MyCombinedBusinessOperation\",\"MyCombinedBusinessOperation\",\"/irisdev/app/src/python/demo/\",1,\"PEX.MyCombinedBusinessOperation\") Registering All Components in a File Use the register_file method to add all components in a file to the component list for interoperability. from iop import Utils Utils.register_file(<File>,<OverWrite>,<PackageName>) Example: from iop import Utils Utils.register_file(\"/irisdev/app/src/python/demo/bo.py\",1,\"PEX\") Registering All Components in a Folder Use the register_folder method to add all components in a folder to the component list for interoperability. from iop import Utils Utils.register_folder(<Path>,<OverWrite>,<PackageName>) Example: from iop import Utils Utils.register_folder(\"/irisdev/app/src/python/demo/\",1,\"PEX\") Migrating Settings Use the migrate method to migrate the settings file to the IRIS framework. from iop import Utils Utils.migrate() The settings.py File This file is used to store the settings of the interoperability components. It has three sections: CLASSES : Stores the classes of the interoperability components. PRODUCTIONS : Stores the productions of the interoperability components. SCHEMAS : Stores the schemas of the interoperability components. Example: import bp from bo import * from bs import * from msg import RedditPost CLASSES = { 'Python.RedditService': RedditService, 'Python.FilterPostRoutingRule': bp.FilterPostRoutingRule, 'Python.FileOperation': FileOperation, 'Python.FileOperationWithIrisAdapter': FileOperationWithIrisAdapter, } SCHEMAS = [RedditPost] PRODUCTIONS = [ { 'dc.Python.Production': { \"@Name\": \"dc.Demo.Production\", \"@TestingEnabled\": \"true\", \"@LogGeneralTraceEvents\": \"false\", \"Description\": \"\", \"ActorPoolSize\": \"2\", \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@Category\": \"\", \"@ClassName\": \"Python.FileOperation\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"true\", \"@Schedule\": \"\", \"Setting\": { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": \"path=/tmp\" } }, { \"@Name\": \"Python.RedditService\", \"@Category\": \"\", \"@ClassName\": \"Python.RedditService\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"false\", \"@Schedule\": \"\", \"Setting\": [ { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": \"limit=10\\nother<10\" } ] }, { \"@Name\": \"Python.FilterPostRoutingRule\", \"@Category\": \"\", \"@ClassName\": \"Python.FilterPostRoutingRule\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"false\", \"@Schedule\": \"\" } ] } } ] The CLASSES Section This section stores the classes of the interoperability components. It helps to register the components. The dictionary has the following structure: Key: The name of the component Value: The class of the component (you have to import it before) The module of the component (you have to import it before) Another dictionary with the following structure: module : Name of the module of the component (optional) class : Name of the class of the component (optional) path : The path of the component (mandatory) Example: When Value is a class or a module: import bo import bp from bs import RedditService CLASSES = { 'Python.RedditService': RedditService, 'Python.FilterPostRoutingRule': bp.FilterPostRoutingRule, 'Python.FileOperation': bo, } When Value is a dictionary: CLASSES = { 'Python.RedditService': { 'module': 'bs', 'class': 'RedditService', 'path': '/irisdev/app/src/python/demo/' }, 'Python.Module': { 'module': 'bp', 'path': '/irisdev/app/src/python/demo/' }, 'Python.Package': { 'path': '/irisdev/app/src/python/demo/' }, } The PRODUCTIONS Section This section stores the productions of the interoperability components. It helps to register a production. The list has the following structure: A list of dictionaries with the following structure: dc.Python.Production : The name of the production @Name : The name of the production @TestingEnabled : The testing enabled of the production @LogGeneralTraceEvents : The log general trace events of the production Description : The description of the production ActorPoolSize : The actor pool size of the production Item : The list of the items of the production @Name : The name of the item @Category : The category of the item @ClassName : The class name of the item @PoolSize : The pool size of the item @Enabled : The enabled of the item @Foreground : The foreground of the item @Comment : The comment of the item @LogTraceEvents : The log trace events of the item @Schedule : The schedule of the item Setting : The list of the settings of the item @Target : The target of the setting @Name : The name of the setting #text : The value of the setting The minimum structure of a production is: PRODUCTIONS = [ { 'UnitTest.Production': { \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@ClassName\": \"Python.FileOperation\", }, { \"@Name\": \"Python.EmailOperation\", \"@ClassName\": \"UnitTest.Package.EmailOperation\" } ] } } ] You can also set in @ClassName an item from the CLASSES section. Example: from bo import FileOperation PRODUCTIONS = [ { 'UnitTest.Production': { \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@ClassName\": FileOperation, } ] } } ] As the production is a dictionary, you can add in the value of the production dictionary an environment variable. Example: import os PRODUCTIONS = [ { 'UnitTest.Production': { \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@ClassName\": \"Python.FileOperation\", \"Setting\": { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": os.environ['SETTINGS'] } } ] } } ] The SCHEMAS Section This section stores the schemas of the interoperability components. It helps to register the schemas for DTL transformations. The list has the following structure: A list of classes Example: from msg import RedditPost SCHEMAS = [RedditPost]","title":"Register Component"},{"location":"getting-started/register-component/#registering-components","text":"There are two main ways to register your Python components with IRIS Interoperability: With a settings file With a Python script: Register a single component using register_component Register all components in a file using register_file Register all components in a folder using register_folder","title":"Registering Components"},{"location":"getting-started/register-component/#with-a-settings-file","text":"Create a settings.py file in the root of your project. This file will be used to register your classes and productions.","title":"With a Settings File"},{"location":"getting-started/register-component/#example-of-settingspy","text":"import bo CLASSES = { \"Python.MyBusinessOperation\": bo.MyBusinessOperation }","title":"Example of settings.py"},{"location":"getting-started/register-component/#registering-the-component","text":"Use the iop command line to register your component: iop --migrate /path/to/your/project/setting.py","title":"Registering the Component"},{"location":"getting-started/register-component/#using-the-python-shell","text":"","title":"Using the Python Shell"},{"location":"getting-started/register-component/#registering-a-single-component","text":"Use the register_component method to add a new Python file to the component list for interoperability. from iop import Utils Utils.register_component(<ModuleName>,<ClassName>,<PathToPyFile>,<OverWrite>,<NameOfTheComponent>) Example: from iop import Utils Utils.register_component(\"MyCombinedBusinessOperation\",\"MyCombinedBusinessOperation\",\"/irisdev/app/src/python/demo/\",1,\"PEX.MyCombinedBusinessOperation\")","title":"Registering a Single Component"},{"location":"getting-started/register-component/#registering-all-components-in-a-file","text":"Use the register_file method to add all components in a file to the component list for interoperability. from iop import Utils Utils.register_file(<File>,<OverWrite>,<PackageName>) Example: from iop import Utils Utils.register_file(\"/irisdev/app/src/python/demo/bo.py\",1,\"PEX\")","title":"Registering All Components in a File"},{"location":"getting-started/register-component/#registering-all-components-in-a-folder","text":"Use the register_folder method to add all components in a folder to the component list for interoperability. from iop import Utils Utils.register_folder(<Path>,<OverWrite>,<PackageName>) Example: from iop import Utils Utils.register_folder(\"/irisdev/app/src/python/demo/\",1,\"PEX\")","title":"Registering All Components in a Folder"},{"location":"getting-started/register-component/#migrating-settings","text":"Use the migrate method to migrate the settings file to the IRIS framework. from iop import Utils Utils.migrate()","title":"Migrating Settings"},{"location":"getting-started/register-component/#the-settingspy-file","text":"This file is used to store the settings of the interoperability components. It has three sections: CLASSES : Stores the classes of the interoperability components. PRODUCTIONS : Stores the productions of the interoperability components. SCHEMAS : Stores the schemas of the interoperability components. Example: import bp from bo import * from bs import * from msg import RedditPost CLASSES = { 'Python.RedditService': RedditService, 'Python.FilterPostRoutingRule': bp.FilterPostRoutingRule, 'Python.FileOperation': FileOperation, 'Python.FileOperationWithIrisAdapter': FileOperationWithIrisAdapter, } SCHEMAS = [RedditPost] PRODUCTIONS = [ { 'dc.Python.Production': { \"@Name\": \"dc.Demo.Production\", \"@TestingEnabled\": \"true\", \"@LogGeneralTraceEvents\": \"false\", \"Description\": \"\", \"ActorPoolSize\": \"2\", \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@Category\": \"\", \"@ClassName\": \"Python.FileOperation\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"true\", \"@Schedule\": \"\", \"Setting\": { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": \"path=/tmp\" } }, { \"@Name\": \"Python.RedditService\", \"@Category\": \"\", \"@ClassName\": \"Python.RedditService\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"false\", \"@Schedule\": \"\", \"Setting\": [ { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": \"limit=10\\nother<10\" } ] }, { \"@Name\": \"Python.FilterPostRoutingRule\", \"@Category\": \"\", \"@ClassName\": \"Python.FilterPostRoutingRule\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"false\", \"@Schedule\": \"\" } ] } } ]","title":"The settings.py File"},{"location":"getting-started/register-component/#the-classes-section","text":"This section stores the classes of the interoperability components. It helps to register the components. The dictionary has the following structure: Key: The name of the component Value: The class of the component (you have to import it before) The module of the component (you have to import it before) Another dictionary with the following structure: module : Name of the module of the component (optional) class : Name of the class of the component (optional) path : The path of the component (mandatory) Example: When Value is a class or a module: import bo import bp from bs import RedditService CLASSES = { 'Python.RedditService': RedditService, 'Python.FilterPostRoutingRule': bp.FilterPostRoutingRule, 'Python.FileOperation': bo, } When Value is a dictionary: CLASSES = { 'Python.RedditService': { 'module': 'bs', 'class': 'RedditService', 'path': '/irisdev/app/src/python/demo/' }, 'Python.Module': { 'module': 'bp', 'path': '/irisdev/app/src/python/demo/' }, 'Python.Package': { 'path': '/irisdev/app/src/python/demo/' }, }","title":"The CLASSES Section"},{"location":"getting-started/register-component/#the-productions-section","text":"This section stores the productions of the interoperability components. It helps to register a production. The list has the following structure: A list of dictionaries with the following structure: dc.Python.Production : The name of the production @Name : The name of the production @TestingEnabled : The testing enabled of the production @LogGeneralTraceEvents : The log general trace events of the production Description : The description of the production ActorPoolSize : The actor pool size of the production Item : The list of the items of the production @Name : The name of the item @Category : The category of the item @ClassName : The class name of the item @PoolSize : The pool size of the item @Enabled : The enabled of the item @Foreground : The foreground of the item @Comment : The comment of the item @LogTraceEvents : The log trace events of the item @Schedule : The schedule of the item Setting : The list of the settings of the item @Target : The target of the setting @Name : The name of the setting #text : The value of the setting The minimum structure of a production is: PRODUCTIONS = [ { 'UnitTest.Production': { \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@ClassName\": \"Python.FileOperation\", }, { \"@Name\": \"Python.EmailOperation\", \"@ClassName\": \"UnitTest.Package.EmailOperation\" } ] } } ] You can also set in @ClassName an item from the CLASSES section. Example: from bo import FileOperation PRODUCTIONS = [ { 'UnitTest.Production': { \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@ClassName\": FileOperation, } ] } } ] As the production is a dictionary, you can add in the value of the production dictionary an environment variable. Example: import os PRODUCTIONS = [ { 'UnitTest.Production': { \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@ClassName\": \"Python.FileOperation\", \"Setting\": { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": os.environ['SETTINGS'] } } ] } } ]","title":"The PRODUCTIONS Section"},{"location":"getting-started/register-component/#the-schemas-section","text":"This section stores the schemas of the interoperability components. It helps to register the schemas for DTL transformations. The list has the following structure: A list of classes Example: from msg import RedditPost SCHEMAS = [RedditPost]","title":"The SCHEMAS Section"}]}