{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"IoP (Interoperability On Python) Welcome to the Interoperability On Python (IoP) proof of concept! This project demonstrates how the IRIS Interoperability Framework can be utilized with a Python-first approach . Example Here's a simple example of how a Business Operation can be implemented in Python: from iop import BusinessOperation class MyBo(BusinessOperation): def on_message(self, request): self.log_info(\"Hello World\") Installation To start using this proof of concept, install it using pip: pip install iris-pex-embedded-python Getting Started If you're new to this proof of concept, begin by reading the installation guide . Then, follow the first steps to create your first Business Operation. Happy coding!","title":"Home"},{"location":"#iop-interoperability-on-python","text":"Welcome to the Interoperability On Python (IoP) proof of concept! This project demonstrates how the IRIS Interoperability Framework can be utilized with a Python-first approach .","title":"IoP (Interoperability On Python)"},{"location":"#example","text":"Here's a simple example of how a Business Operation can be implemented in Python: from iop import BusinessOperation class MyBo(BusinessOperation): def on_message(self, request): self.log_info(\"Hello World\")","title":"Example"},{"location":"#installation","text":"To start using this proof of concept, install it using pip: pip install iris-pex-embedded-python","title":"Installation"},{"location":"#getting-started","text":"If you're new to this proof of concept, begin by reading the installation guide . Then, follow the first steps to create your first Business Operation. Happy coding!","title":"Getting Started"},{"location":"benchmarks/","text":"Benchmarks 8 senarios with thoses parameters : - 100 messages - body : simple string test Scenario Time (s) Python BP to Python BO with Iris Message 0.239 Python BP to Python BO with Python Message 0.232 ObjetScript BP to Python BO with Iris Message 0.294 ObjetScript BP to Python BO with Python Message 0.242 Python BP to ObjetScript BO with Iris Message 0.242 Python BP to ObjetScript BO with Python Message 0.275 ObjetScript BP to ObjetScript BO with Iris Message 0.159 ObjetScript BP to ObjetScript BO with Python Message 0.182 Benchmarked can be run in the unit test with the following command : pytest src/tests/test_bench.py","title":"Benchmarks"},{"location":"benchmarks/#benchmarks","text":"8 senarios with thoses parameters : - 100 messages - body : simple string test Scenario Time (s) Python BP to Python BO with Iris Message 0.239 Python BP to Python BO with Python Message 0.232 ObjetScript BP to Python BO with Iris Message 0.294 ObjetScript BP to Python BO with Python Message 0.242 Python BP to ObjetScript BO with Iris Message 0.242 Python BP to ObjetScript BO with Python Message 0.275 ObjetScript BP to ObjetScript BO with Iris Message 0.159 ObjetScript BP to ObjetScript BO with Python Message 0.182 Benchmarked can be run in the unit test with the following command : pytest src/tests/test_bench.py","title":"Benchmarks"},{"location":"command-line/","text":"Command line Since version 2.3.1, you can use the command line to register your components and productions. To use it, you have to use the following command : iop output : usage: python3 -m iop [-h] [-d DEFAULT] [-l] [-s START] [-k] [-S] [-r] [-M MIGRATE] [-e EXPORT] [-x] [-v] [-L] optional arguments: -h, --help display help and default production name -d DEFAULT, --default DEFAULT set the default production -l, --lists list productions -s START, --start START start a production -k, --kill kill a production (force stop) -S, --stop stop a production -r, --restart restart a production -M MIGRATE, --migrate MIGRATE migrate production and classes with settings file -e EXPORT, --export EXPORT export a production -x, --status status a production -v, --version display version -L, --log display log default production: PEX.Production help The help command display the help and the default production name. iop -h output : usage: python3 -m iop [-h] [-d DEFAULT] [-l] [-s START] [-k] [-S] [-r] [-M MIGRATE] [-e EXPORT] [-x] [-v] [-L] ... default production: PEX.Production default The default command set the default production. With no argument, it display the default production. iop -d output : default production: PEX.Production With an argument, it set the default production. iop -d PEX.Production lists The lists command list productions. iop -l output : { \"PEX.Production\": { \"Status\": \"Stopped\", \"LastStartTime\": \"2023-05-31 11:13:51.000\", \"LastStopTime\": \"2023-05-31 11:13:54.153\", \"AutoStart\": 0 } } start The start command start a production. To exit the command, you have to press CTRL+C. iop -s PEX.Production output : 2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting production 2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting item Python.FileOperation 2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting item Python.EmailOperation ... kill The kill command kill a production (force stop). Kill command is the same as stop command but with a force stop. Kill command doesn't take an argument because only one production can be running. iop -k stop The stop command stop a production. Stop command doesn't take an argument because only one production can be running. iop -S restart The restart command restart a production. Restart command doesn't take an argument because only one production can be running. iop -r migrate The migrate command migrate a production and classes with settings file. Migrate command must take the absolute path of the settings file. Settings file must be in the same folder as the python code. iop -M /tmp/settings.py More details about the settings file can be found here . export The export command export a production. If no argument is given, the export command export the default production. iop -e If an argument is given, the export command export the production given in argument. iop -e PEX.Production output : { \"Production\": { \"@Name\": \"PEX.Production\", \"@TestingEnabled\": \"true\", \"@LogGeneralTraceEvents\": \"false\", \"Description\": \"\", \"ActorPoolSize\": \"2\", \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@Category\": \"\", \"@ClassName\": \"Python.FileOperation\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"true\", \"@Schedule\": \"\", \"Setting\": [ { \"@Target\": \"Adapter\", \"@Name\": \"Charset\", \"#text\": \"utf-8\" }, { \"@Target\": \"Adapter\", \"@Name\": \"FilePath\", \"#text\": \"/irisdev/app/output/\" }, { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": \"path=/irisdev/app/output/\" } ] } ] } } status The status command status a production. Status command doesn't take an argument because only one production can be running. iop -x output : { \"Production\": \"PEX.Production\", \"Status\": \"stopped\" } Status can be : - stopped - running - suspended - troubled version The version command display the version. iop -v output : 2.3.0 log The log command display the log. To exit the command, you have to press CTRL+C. iop -L output : 2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting production 2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting item Python.FileOperation 2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting item Python.EmailOperation ...","title":"Command Line Interface"},{"location":"command-line/#command-line","text":"Since version 2.3.1, you can use the command line to register your components and productions. To use it, you have to use the following command : iop output : usage: python3 -m iop [-h] [-d DEFAULT] [-l] [-s START] [-k] [-S] [-r] [-M MIGRATE] [-e EXPORT] [-x] [-v] [-L] optional arguments: -h, --help display help and default production name -d DEFAULT, --default DEFAULT set the default production -l, --lists list productions -s START, --start START start a production -k, --kill kill a production (force stop) -S, --stop stop a production -r, --restart restart a production -M MIGRATE, --migrate MIGRATE migrate production and classes with settings file -e EXPORT, --export EXPORT export a production -x, --status status a production -v, --version display version -L, --log display log default production: PEX.Production","title":"Command line"},{"location":"command-line/#help","text":"The help command display the help and the default production name. iop -h output : usage: python3 -m iop [-h] [-d DEFAULT] [-l] [-s START] [-k] [-S] [-r] [-M MIGRATE] [-e EXPORT] [-x] [-v] [-L] ... default production: PEX.Production","title":"help"},{"location":"command-line/#default","text":"The default command set the default production. With no argument, it display the default production. iop -d output : default production: PEX.Production With an argument, it set the default production. iop -d PEX.Production","title":"default"},{"location":"command-line/#lists","text":"The lists command list productions. iop -l output : { \"PEX.Production\": { \"Status\": \"Stopped\", \"LastStartTime\": \"2023-05-31 11:13:51.000\", \"LastStopTime\": \"2023-05-31 11:13:54.153\", \"AutoStart\": 0 } }","title":"lists"},{"location":"command-line/#start","text":"The start command start a production. To exit the command, you have to press CTRL+C. iop -s PEX.Production output : 2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting production 2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting item Python.FileOperation 2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting item Python.EmailOperation ...","title":"start"},{"location":"command-line/#kill","text":"The kill command kill a production (force stop). Kill command is the same as stop command but with a force stop. Kill command doesn't take an argument because only one production can be running. iop -k","title":"kill"},{"location":"command-line/#stop","text":"The stop command stop a production. Stop command doesn't take an argument because only one production can be running. iop -S","title":"stop"},{"location":"command-line/#restart","text":"The restart command restart a production. Restart command doesn't take an argument because only one production can be running. iop -r","title":"restart"},{"location":"command-line/#migrate","text":"The migrate command migrate a production and classes with settings file. Migrate command must take the absolute path of the settings file. Settings file must be in the same folder as the python code. iop -M /tmp/settings.py More details about the settings file can be found here .","title":"migrate"},{"location":"command-line/#export","text":"The export command export a production. If no argument is given, the export command export the default production. iop -e If an argument is given, the export command export the production given in argument. iop -e PEX.Production output : { \"Production\": { \"@Name\": \"PEX.Production\", \"@TestingEnabled\": \"true\", \"@LogGeneralTraceEvents\": \"false\", \"Description\": \"\", \"ActorPoolSize\": \"2\", \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@Category\": \"\", \"@ClassName\": \"Python.FileOperation\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"true\", \"@Schedule\": \"\", \"Setting\": [ { \"@Target\": \"Adapter\", \"@Name\": \"Charset\", \"#text\": \"utf-8\" }, { \"@Target\": \"Adapter\", \"@Name\": \"FilePath\", \"#text\": \"/irisdev/app/output/\" }, { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": \"path=/irisdev/app/output/\" } ] } ] } }","title":"export"},{"location":"command-line/#status","text":"The status command status a production. Status command doesn't take an argument because only one production can be running. iop -x output : { \"Production\": \"PEX.Production\", \"Status\": \"stopped\" } Status can be : - stopped - running - suspended - troubled","title":"status"},{"location":"command-line/#version","text":"The version command display the version. iop -v output : 2.3.0","title":"version"},{"location":"command-line/#log","text":"The log command display the log. To exit the command, you have to press CTRL+C. iop -L output : 2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting production 2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting item Python.FileOperation 2021-08-30 15:13:51.000 [PEX.Production] INFO: Starting item Python.EmailOperation ...","title":"log"},{"location":"credits/","text":"Credits Most of the code came from PEX for Python by Mo Cheng and Summer Gerry.","title":"Credits"},{"location":"credits/#credits","text":"Most of the code came from PEX for Python by Mo Cheng and Summer Gerry.","title":"Credits"},{"location":"dtl/","text":"DTL Support Starting with version 3.2.0, IoP supports DTL transformations. DTL the Data Transformation Layer in IRIS Interoperability. DTL transformations are used to transform data from one format to another with a graphical editor. It supports also jsonschema structures. How to use DTL in with Message First you need to register you message class is a settings.py file. To do so, you need to add the following line in the settings.py file: settings.py from msg import MyMessage SCHEMAS = [MyMessage] Then you can use iop migration command to generate schema files for your message classes. iop --migrate /path/to/your/project/settings.py Example msg.py from iop import Message from dataclasses import dataclass @dataclass class MyMessage(Message): name: str = None age: int = None settings.py from msg import MyMessage SCHEMAS = [MyMessage] Migrate the schema files iop --migrate /path/to/your/project/settings.py Building a DTL Transformation To build a DTL transformation, you need to create a new DTL transformation class. Go to the IRIS Interoperability Management Portal and create a new DTL transformation. Then select the source and target message classes. And it's schema. Then you can start building your transformation. You can even test your transformation. Example of payload to test as a source message: <test> <Message> <json><![CDATA[ { \"list_str\":[\"toto\",\"titi\"], \"post\":{\"Title\":\"foo\",\"Selftext\":\"baz\"}, \"list_post\":[{\"Title\":\"bar\",\"Selftext\":\"baz\"},{\"Title\":\"foo\",\"Selftext\":\"foo\"}] } ]]></json> </Message> </test> JsonSchema Support Starting with version 3.2.0, IoP supports jsonschema structures for DTL transformations. Same as for message classes, you need to register your jsonschema . To do so, you need to invoke his iris command: zw ##class(IOP.Message.JSONSchema).ImportFromFile(\"/irisdev/app/random_jsonschema.json\",\"Demo\",\"Demo\") Where the first argument is the path to the jsonschema file, the second argument is the package name and the third argument is the name of the schema. Then you can use it in your DTL transformation. The schema will be available in the name of Demo . Example jsonschema file: { \"$schema\": \"https://json-schema.org/draft/2020-12/schema\", \"type\": \"object\", \"title\": \"PostMessage\", \"properties\": { \"post\": { \"allOf\": [ { \"$ref\": \"#/$defs/PostClass\" } ] }, \"to_email_address\": { \"type\": \"string\", \"default\": null }, \"my_list\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } }, \"found\": { \"type\": \"string\", \"default\": null }, \"list_of_post\": { \"type\": \"array\", \"items\": { \"allOf\": [ { \"$ref\": \"#/$defs/PostClass\" } ] } } }, \"$defs\": { \"PostClass\": { \"type\": \"object\", \"title\": \"PostClass\", \"properties\": { \"title\": { \"type\": \"string\" }, \"selftext\": { \"type\": \"string\" }, \"author\": { \"type\": \"string\" }, \"url\": { \"type\": \"string\" }, \"created_utc\": { \"type\": \"number\" }, \"original_json\": { \"type\": \"string\", \"default\": null } }, \"required\": [ \"title\", \"selftext\", \"author\", \"url\", \"created_utc\" ] } } } Example of DTL Transformation with JsonSchema or Message Class Many can be found in the UnitTest package ./src/tests/cls directory. Class UnitTest.ComplexTransform Extends Ens.DataTransformDTL [ DependsOn = IOP.Message ] { Parameter IGNOREMISSINGSOURCE = 1; Parameter REPORTERRORS = 1; Parameter TREATEMPTYREPEATINGFIELDASNULL = 0; XData DTL [ XMLNamespace = \"http://www.intersystems.com/dtl\" ] { <transform sourceClass='IOP.Message' targetClass='IOP.Message' sourceDocType='registerFilesIop.message.ComplexMessage' targetDocType='registerFilesIop.message.ComplexMessage' create='new' language='objectscript' > <assign value='source.{post}' property='target.{post}' action='set' /> <foreach property='source.{list_str()}' key='k1' > <assign value='source.{list_str(k1)}_\"foo\"' property='target.{list_str()}' action='append' /> </foreach> <foreach property='source.{list_post()}' key='k2' > <assign value='source.{list_post().Title}' property='target.{list_post(k2).Title}' action='append' /> </foreach> </transform> } }","title":"DTL Support"},{"location":"dtl/#dtl-support","text":"Starting with version 3.2.0, IoP supports DTL transformations. DTL the Data Transformation Layer in IRIS Interoperability. DTL transformations are used to transform data from one format to another with a graphical editor. It supports also jsonschema structures.","title":"DTL Support"},{"location":"dtl/#how-to-use-dtl-in-with-message","text":"First you need to register you message class is a settings.py file. To do so, you need to add the following line in the settings.py file: settings.py from msg import MyMessage SCHEMAS = [MyMessage] Then you can use iop migration command to generate schema files for your message classes. iop --migrate /path/to/your/project/settings.py","title":"How to use DTL in with Message"},{"location":"dtl/#example","text":"msg.py from iop import Message from dataclasses import dataclass @dataclass class MyMessage(Message): name: str = None age: int = None settings.py from msg import MyMessage SCHEMAS = [MyMessage] Migrate the schema files iop --migrate /path/to/your/project/settings.py","title":"Example"},{"location":"dtl/#building-a-dtl-transformation","text":"To build a DTL transformation, you need to create a new DTL transformation class. Go to the IRIS Interoperability Management Portal and create a new DTL transformation. Then select the source and target message classes. And it's schema. Then you can start building your transformation. You can even test your transformation. Example of payload to test as a source message: <test> <Message> <json><![CDATA[ { \"list_str\":[\"toto\",\"titi\"], \"post\":{\"Title\":\"foo\",\"Selftext\":\"baz\"}, \"list_post\":[{\"Title\":\"bar\",\"Selftext\":\"baz\"},{\"Title\":\"foo\",\"Selftext\":\"foo\"}] } ]]></json> </Message> </test>","title":"Building a DTL Transformation"},{"location":"dtl/#jsonschema-support","text":"Starting with version 3.2.0, IoP supports jsonschema structures for DTL transformations. Same as for message classes, you need to register your jsonschema . To do so, you need to invoke his iris command: zw ##class(IOP.Message.JSONSchema).ImportFromFile(\"/irisdev/app/random_jsonschema.json\",\"Demo\",\"Demo\") Where the first argument is the path to the jsonschema file, the second argument is the package name and the third argument is the name of the schema. Then you can use it in your DTL transformation. The schema will be available in the name of Demo . Example jsonschema file: { \"$schema\": \"https://json-schema.org/draft/2020-12/schema\", \"type\": \"object\", \"title\": \"PostMessage\", \"properties\": { \"post\": { \"allOf\": [ { \"$ref\": \"#/$defs/PostClass\" } ] }, \"to_email_address\": { \"type\": \"string\", \"default\": null }, \"my_list\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } }, \"found\": { \"type\": \"string\", \"default\": null }, \"list_of_post\": { \"type\": \"array\", \"items\": { \"allOf\": [ { \"$ref\": \"#/$defs/PostClass\" } ] } } }, \"$defs\": { \"PostClass\": { \"type\": \"object\", \"title\": \"PostClass\", \"properties\": { \"title\": { \"type\": \"string\" }, \"selftext\": { \"type\": \"string\" }, \"author\": { \"type\": \"string\" }, \"url\": { \"type\": \"string\" }, \"created_utc\": { \"type\": \"number\" }, \"original_json\": { \"type\": \"string\", \"default\": null } }, \"required\": [ \"title\", \"selftext\", \"author\", \"url\", \"created_utc\" ] } } }","title":"JsonSchema Support"},{"location":"dtl/#example-of-dtl-transformation-with-jsonschema-or-message-class","text":"Many can be found in the UnitTest package ./src/tests/cls directory. Class UnitTest.ComplexTransform Extends Ens.DataTransformDTL [ DependsOn = IOP.Message ] { Parameter IGNOREMISSINGSOURCE = 1; Parameter REPORTERRORS = 1; Parameter TREATEMPTYREPEATINGFIELDASNULL = 0; XData DTL [ XMLNamespace = \"http://www.intersystems.com/dtl\" ] { <transform sourceClass='IOP.Message' targetClass='IOP.Message' sourceDocType='registerFilesIop.message.ComplexMessage' targetDocType='registerFilesIop.message.ComplexMessage' create='new' language='objectscript' > <assign value='source.{post}' property='target.{post}' action='set' /> <foreach property='source.{list_str()}' key='k1' > <assign value='source.{list_str(k1)}_\"foo\"' property='target.{list_str()}' action='append' /> </foreach> <foreach property='source.{list_post()}' key='k2' > <assign value='source.{list_post().Title}' property='target.{list_post(k2).Title}' action='append' /> </foreach> </transform> } }","title":"Example of DTL Transformation with JsonSchema or Message Class"},{"location":"example/","text":"Example This document provides an example of a business operation and messages in Python, along with instructions on how to register a component. Business Operation Below is an example of a business operation in Python: from iop import BusinessOperation, Message from dataclasses import dataclass class MyBusinessOperation(BusinessOperation): def on_init(self): # This method is called when the component is becoming active in the production self.log_info(\"[Python] MyBusinessOperation:on_init() is called\") return def on_teardown(self): # This method is called when the component is becoming inactive in the production self.log_info(\"[Python] MyBusinessOperation:on_teardown() is called\") return def on_message(self, message_input: 'MyRequest'): # Called from service/process/operation, message is of type MyRequest with property request_string self.log_info(\"[Python] MyBusinessOperation:on_message() is called with message: \" + message_input.request_string) response = MyResponse(\"MyBusinessOperation:on_message() echos\") return response @dataclass class MyRequest(Message): request_string: str = None @dataclass class MyResponse(Message): my_string: str = None Explanation on_init : This method is called when the component becomes active in the production. on_teardown : This method is called when the component becomes inactive in the production. on_message : This method is called from service/process/operation, and it processes the incoming message of type MyRequest . Register a Component To register a component, create a setting.py file in the root of your project. This file will be used to register your classes and productions. Example of setting.py import bo CLASSES = { \"Python.MyBusinessOperation\": bo.MyBusinessOperation } Registering the Component Use the iop command line to register your component: iop --migrate /path/to/your/project/setting.py","title":"Examples"},{"location":"example/#example","text":"This document provides an example of a business operation and messages in Python, along with instructions on how to register a component.","title":"Example"},{"location":"example/#business-operation","text":"Below is an example of a business operation in Python: from iop import BusinessOperation, Message from dataclasses import dataclass class MyBusinessOperation(BusinessOperation): def on_init(self): # This method is called when the component is becoming active in the production self.log_info(\"[Python] MyBusinessOperation:on_init() is called\") return def on_teardown(self): # This method is called when the component is becoming inactive in the production self.log_info(\"[Python] MyBusinessOperation:on_teardown() is called\") return def on_message(self, message_input: 'MyRequest'): # Called from service/process/operation, message is of type MyRequest with property request_string self.log_info(\"[Python] MyBusinessOperation:on_message() is called with message: \" + message_input.request_string) response = MyResponse(\"MyBusinessOperation:on_message() echos\") return response @dataclass class MyRequest(Message): request_string: str = None @dataclass class MyResponse(Message): my_string: str = None","title":"Business Operation"},{"location":"example/#explanation","text":"on_init : This method is called when the component becomes active in the production. on_teardown : This method is called when the component becomes inactive in the production. on_message : This method is called from service/process/operation, and it processes the incoming message of type MyRequest .","title":"Explanation"},{"location":"example/#register-a-component","text":"To register a component, create a setting.py file in the root of your project. This file will be used to register your classes and productions.","title":"Register a Component"},{"location":"example/#example-of-settingpy","text":"import bo CLASSES = { \"Python.MyBusinessOperation\": bo.MyBusinessOperation }","title":"Example of setting.py"},{"location":"example/#registering-the-component","text":"Use the iop command line to register your component: iop --migrate /path/to/your/project/setting.py","title":"Registering the Component"},{"location":"logging/","text":"Logging InterSystems IRIS Interoperability framework implements its own logging system. The Python API provides a way to use Python's logging module integrated with IRIS logging. Basic Usage The logging system is available through the component base class. You can access it via the logger property or use the convenience methods: def on_init(self): # Using convenience methods self.log_info(\"Component initialized\") self.log_error(\"An error occurred\") self.log_warning(\"Warning message\") self.log_alert(\"Critical alert\") self.trace(\"Debug trace message\") # Using logger property self.logger.info(\"Info via logger\") self.logger.error(\"Error via logger\") Console Logging You can direct logs to the console instead of IRIS in two ways: Set the component-wide setting: def on_init(self): self.log_to_console = True self.log_info(\"This will go to console\") Per-message console logging: def on_message(self, request): # Log specific message to console self.log_info(\"Debug info\", to_console=True) # Other logs still go to IRIS self.log_info(\"Production info\") Log Levels The following log levels are available: trace() - Debug level logging (maps to IRIS LogTrace) log_info() - Information messages (maps to IRIS LogInfo) log_warning() - Warning messages (maps to IRIS LogWarning) log_error() - Error messages (maps to IRIS LogError) log_alert() - Critical/Alert messages (maps to IRIS LogAlert) log_assert() - Assert messages (maps to IRIS LogAssert) Integration with IRIS The Python logging is automatically mapped to the appropriate IRIS logging methods: Python DEBUG \u2192 IRIS LogTrace Python INFO \u2192 IRIS LogInfo Python WARNING \u2192 IRIS LogWarning Python ERROR \u2192 IRIS LogError Python CRITICAL \u2192 IRIS LogAlert Legacy Methods The following methods are deprecated but maintained for backwards compatibility: LOGINFO() - Use log_info() instead LOGALERT() - Use log_alert() instead LOGWARNING() - Use log_warning() instead LOGERROR() - Use log_error() instead LOGASSERT() - Use log_assert() instead","title":"Logging"},{"location":"logging/#logging","text":"InterSystems IRIS Interoperability framework implements its own logging system. The Python API provides a way to use Python's logging module integrated with IRIS logging.","title":"Logging"},{"location":"logging/#basic-usage","text":"The logging system is available through the component base class. You can access it via the logger property or use the convenience methods: def on_init(self): # Using convenience methods self.log_info(\"Component initialized\") self.log_error(\"An error occurred\") self.log_warning(\"Warning message\") self.log_alert(\"Critical alert\") self.trace(\"Debug trace message\") # Using logger property self.logger.info(\"Info via logger\") self.logger.error(\"Error via logger\")","title":"Basic Usage"},{"location":"logging/#console-logging","text":"You can direct logs to the console instead of IRIS in two ways: Set the component-wide setting: def on_init(self): self.log_to_console = True self.log_info(\"This will go to console\") Per-message console logging: def on_message(self, request): # Log specific message to console self.log_info(\"Debug info\", to_console=True) # Other logs still go to IRIS self.log_info(\"Production info\")","title":"Console Logging"},{"location":"logging/#log-levels","text":"The following log levels are available: trace() - Debug level logging (maps to IRIS LogTrace) log_info() - Information messages (maps to IRIS LogInfo) log_warning() - Warning messages (maps to IRIS LogWarning) log_error() - Error messages (maps to IRIS LogError) log_alert() - Critical/Alert messages (maps to IRIS LogAlert) log_assert() - Assert messages (maps to IRIS LogAssert)","title":"Log Levels"},{"location":"logging/#integration-with-iris","text":"The Python logging is automatically mapped to the appropriate IRIS logging methods: Python DEBUG \u2192 IRIS LogTrace Python INFO \u2192 IRIS LogInfo Python WARNING \u2192 IRIS LogWarning Python ERROR \u2192 IRIS LogError Python CRITICAL \u2192 IRIS LogAlert","title":"Integration with IRIS"},{"location":"logging/#legacy-methods","text":"The following methods are deprecated but maintained for backwards compatibility: LOGINFO() - Use log_info() instead LOGALERT() - Use log_alert() instead LOGWARNING() - Use log_warning() instead LOGERROR() - Use log_error() instead LOGASSERT() - Use log_assert() instead","title":"Legacy Methods"},{"location":"python-api/","text":"Python API Documentation Core Classes Message \ud83d\udce6 Base class for messages passed between components. This class provides the foundation for all message types in the interoperability framework. Usage: Subclass Message and decorate with @dataclass to define message properties. This approach provides type hints and automatic initialization. Example: from iop import Message from dataclasses import dataclass @dataclass class MyRequest(Message): request_string: str = None BusinessService \ud83d\udd04 Base class for business services that receive and process incoming data. Business services act as entry points for data into your interoperability solution. Key Methods: on_process_input(self, message_input: Message) -> None Handles incoming messages from adapter Parameters: message_input : The incoming message to process Returns: None send_request_sync(self, target: str, request: Message, timeout: int = -1) -> Message Sends a synchronous request and waits for response Parameters: target : Name of the target component request : Message to send timeout : Maximum wait time in seconds (-1 for default) Returns: Response message send_request_async(self, target: str, request: Message) -> None Sends an asynchronous request without waiting Parameters: target : Name of the target component request : Message to send Returns: None Basic Example: from iop import BusinessService class MyService(BusinessService): def on_process_input(self, message_input): self.log_info(f\"Received: {message_input}\") Advanced Example with Adapter: from iop import BusinessService, Message from dataclasses import dataclass @dataclass class MyRequest(Message): file_path: str = None data: str = None class MyService(BusinessService): def get_adapter_type(): \"\"\"Enable pull mode for the BusinessService\"\"\" return \"Ens.InboundAdapter\" def on_process_input(self, message_input): self.log_info(f\"Received: {message_input}\") with open(message_input.file_path, 'r') as file: data = file.read() request = MyRequest(data=data) self.send_request_async(\"MyBusinessOperation\", request) BusinessOperation \ud83d\udd27 Base class for business operations that process requests and perform specific business logic. Key Methods: on_message(self, request: Message) -> Message Process incoming request messages Parameters: request : The incoming message to process Returns: Response message send_request_sync(self, target: str, request: Message, timeout: int = -1) -> Message Send synchronous request and wait for response Parameters and returns same as BusinessService send_request_async(self, target: str, request: Message) -> None Send asynchronous request without waiting Parameters and returns same as BusinessService Example: from iop import BusinessOperation, Message from dataclasses import dataclass @dataclass class MyRequest(Message): request_string: str = None @dataclass class MyResponse(Message): my_string: str = None class MyOperation(BusinessOperation): def on_message(self, request): self.log_info(f\"Received: {request}\") return MyResponse(my_string=\"Hello World\") BusinessProcess \u200d\ud83d\udcbc Base class for business processes that orchestrate message flow between components. Key Methods: on_request(self, request: Message) -> None Handle initial incoming requests Parameters: request : The incoming request to process Returns: None on_response(self, request: Message, response: Message, call_request: Message, call_response: Message, completion_key: str) -> None Handle asynchronous responses Parameters: request : Original request response : Current response call_request : Request that generated this response call_response : The response being processed completion_key : Unique identifier for the response chain Returns: None on_complete(self, request: Message, response: Message) -> None Called after all responses are received Parameters: request : Original request response : Final response Returns: None reply(self, response: Message) -> None Send response back to the caller Parameters: response : Response message to send Returns: None Example: from iop import BusinessProcess, Message from dataclasses import dataclass @dataclass class MyRequest(Message): request_string: str = None @dataclass class MyResponse(Message): my_string: str = None class MyProcess(BusinessProcess): def on_request(self, request): self.log_info(f\"Received: {request}\") self.send_request_async(\"MyBusinessOperation\", request) def on_response(self, request, response, call_request, call_response, completion_key): self.log_info(f\"Received: {response}\") self.reply(response) Adapter Classes \ud83d\udd0c InboundAdapter Base class for adapters that receive external data. Key Methods: on_task(self) -> None Called at configured intervals to check for new data Override this method to implement custom data acquisition logic Returns: None OutboundAdapter Base class for adapters that send data to external systems. Key Methods: on_keepalive(self) -> None Called periodically to maintain external connections Implement connection maintenance logic here Returns: None Common Methods \ud83d\udee0\ufe0f Available in all component classes: Logging Methods: log_info(self, message: str) -> None Log informational message for general information log_error(self, message: str) -> None Log error message for errors and exceptions log_warning(self, message: str) -> None Log warning message for potential issues log_alert(self, message: str) -> None Log alert message for critical situations Lifecycle Methods: on_init(self) -> None Initialize component when it starts Override to add custom initialization on_tear_down(self) -> None Clean up resources when component stops Override to add custom cleanup logic on_connected(self) -> None Handle connection setup when connections are established Override to add custom connection logic Director Class \ud83c\udfad Manages InterSystems IRIS productions and business services, particularly for non-polling services. Key Methods: Production Management: start_production(production_name: str = None) -> None Start a production If no name provided, uses default production stop_production() -> None Stop the currently running production restart_production() -> None Restart the current production shutdown_production() -> None Gracefully shutdown the production status_production() -> dict Get current production status Returns dictionary with production details Business Service Management: create_business_service(target: str) -> object Create an instance of a business service Parameters: target : Name of the business service in production Returns: Business service instance get_business_service(target: str) -> object Get an existing business service instance Parameters: target : Name of the business service in production Returns: Business service instance test_component(target: str, message=None, classname: str=None, body=None) -> object Test a production component Parameters: target : Component name message : Optional message instance classname : Optional message class name body : Optional message body Returns: Component response Production Logging: log_production() -> None Start real-time production log monitoring Press Ctrl+C to stop log_production_top(top: int) -> None Display last N log entries Parameters: top : Number of entries to show Production Configuration: set_default_production(production_name: str) -> None Set the default production name get_default_production() -> str Get the current default production name Example Usage: In a flask application : from iop import Director from flask import Flask app = Flask(__name__) director = Director() @app.route('/') def hello_world(): bs = director.get_business_service(\"MyBusinessService\") return bs.on_process_input(\"Hello, World!\")","title":"Python API"},{"location":"python-api/#python-api-documentation","text":"","title":"Python API Documentation"},{"location":"python-api/#core-classes","text":"","title":"Core Classes"},{"location":"python-api/#message","text":"Base class for messages passed between components. This class provides the foundation for all message types in the interoperability framework. Usage: Subclass Message and decorate with @dataclass to define message properties. This approach provides type hints and automatic initialization. Example: from iop import Message from dataclasses import dataclass @dataclass class MyRequest(Message): request_string: str = None","title":"Message \ud83d\udce6"},{"location":"python-api/#businessservice","text":"Base class for business services that receive and process incoming data. Business services act as entry points for data into your interoperability solution. Key Methods: on_process_input(self, message_input: Message) -> None Handles incoming messages from adapter Parameters: message_input : The incoming message to process Returns: None send_request_sync(self, target: str, request: Message, timeout: int = -1) -> Message Sends a synchronous request and waits for response Parameters: target : Name of the target component request : Message to send timeout : Maximum wait time in seconds (-1 for default) Returns: Response message send_request_async(self, target: str, request: Message) -> None Sends an asynchronous request without waiting Parameters: target : Name of the target component request : Message to send Returns: None Basic Example: from iop import BusinessService class MyService(BusinessService): def on_process_input(self, message_input): self.log_info(f\"Received: {message_input}\") Advanced Example with Adapter: from iop import BusinessService, Message from dataclasses import dataclass @dataclass class MyRequest(Message): file_path: str = None data: str = None class MyService(BusinessService): def get_adapter_type(): \"\"\"Enable pull mode for the BusinessService\"\"\" return \"Ens.InboundAdapter\" def on_process_input(self, message_input): self.log_info(f\"Received: {message_input}\") with open(message_input.file_path, 'r') as file: data = file.read() request = MyRequest(data=data) self.send_request_async(\"MyBusinessOperation\", request)","title":"BusinessService \ud83d\udd04"},{"location":"python-api/#businessoperation","text":"Base class for business operations that process requests and perform specific business logic. Key Methods: on_message(self, request: Message) -> Message Process incoming request messages Parameters: request : The incoming message to process Returns: Response message send_request_sync(self, target: str, request: Message, timeout: int = -1) -> Message Send synchronous request and wait for response Parameters and returns same as BusinessService send_request_async(self, target: str, request: Message) -> None Send asynchronous request without waiting Parameters and returns same as BusinessService Example: from iop import BusinessOperation, Message from dataclasses import dataclass @dataclass class MyRequest(Message): request_string: str = None @dataclass class MyResponse(Message): my_string: str = None class MyOperation(BusinessOperation): def on_message(self, request): self.log_info(f\"Received: {request}\") return MyResponse(my_string=\"Hello World\")","title":"BusinessOperation \ud83d\udd27"},{"location":"python-api/#businessprocess","text":"Base class for business processes that orchestrate message flow between components. Key Methods: on_request(self, request: Message) -> None Handle initial incoming requests Parameters: request : The incoming request to process Returns: None on_response(self, request: Message, response: Message, call_request: Message, call_response: Message, completion_key: str) -> None Handle asynchronous responses Parameters: request : Original request response : Current response call_request : Request that generated this response call_response : The response being processed completion_key : Unique identifier for the response chain Returns: None on_complete(self, request: Message, response: Message) -> None Called after all responses are received Parameters: request : Original request response : Final response Returns: None reply(self, response: Message) -> None Send response back to the caller Parameters: response : Response message to send Returns: None Example: from iop import BusinessProcess, Message from dataclasses import dataclass @dataclass class MyRequest(Message): request_string: str = None @dataclass class MyResponse(Message): my_string: str = None class MyProcess(BusinessProcess): def on_request(self, request): self.log_info(f\"Received: {request}\") self.send_request_async(\"MyBusinessOperation\", request) def on_response(self, request, response, call_request, call_response, completion_key): self.log_info(f\"Received: {response}\") self.reply(response)","title":"BusinessProcess \u200d\ud83d\udcbc"},{"location":"python-api/#adapter-classes","text":"","title":"Adapter Classes \ud83d\udd0c"},{"location":"python-api/#inboundadapter","text":"Base class for adapters that receive external data. Key Methods: on_task(self) -> None Called at configured intervals to check for new data Override this method to implement custom data acquisition logic Returns: None","title":"InboundAdapter"},{"location":"python-api/#outboundadapter","text":"Base class for adapters that send data to external systems. Key Methods: on_keepalive(self) -> None Called periodically to maintain external connections Implement connection maintenance logic here Returns: None","title":"OutboundAdapter"},{"location":"python-api/#common-methods","text":"Available in all component classes: Logging Methods: log_info(self, message: str) -> None Log informational message for general information log_error(self, message: str) -> None Log error message for errors and exceptions log_warning(self, message: str) -> None Log warning message for potential issues log_alert(self, message: str) -> None Log alert message for critical situations Lifecycle Methods: on_init(self) -> None Initialize component when it starts Override to add custom initialization on_tear_down(self) -> None Clean up resources when component stops Override to add custom cleanup logic on_connected(self) -> None Handle connection setup when connections are established Override to add custom connection logic","title":"Common Methods \ud83d\udee0\ufe0f"},{"location":"python-api/#director-class","text":"Manages InterSystems IRIS productions and business services, particularly for non-polling services. Key Methods: Production Management: start_production(production_name: str = None) -> None Start a production If no name provided, uses default production stop_production() -> None Stop the currently running production restart_production() -> None Restart the current production shutdown_production() -> None Gracefully shutdown the production status_production() -> dict Get current production status Returns dictionary with production details Business Service Management: create_business_service(target: str) -> object Create an instance of a business service Parameters: target : Name of the business service in production Returns: Business service instance get_business_service(target: str) -> object Get an existing business service instance Parameters: target : Name of the business service in production Returns: Business service instance test_component(target: str, message=None, classname: str=None, body=None) -> object Test a production component Parameters: target : Component name message : Optional message instance classname : Optional message class name body : Optional message body Returns: Component response Production Logging: log_production() -> None Start real-time production log monitoring Press Ctrl+C to stop log_production_top(top: int) -> None Display last N log entries Parameters: top : Number of entries to show Production Configuration: set_default_production(production_name: str) -> None Set the default production name get_default_production() -> str Get the current default production name Example Usage: In a flask application : from iop import Director from flask import Flask app = Flask(__name__) director = Director() @app.route('/') def hello_world(): bs = director.get_business_service(\"MyBusinessService\") return bs.on_process_input(\"Hello, World!\")","title":"Director Class \ud83c\udfad"},{"location":"useful-links/","text":"Useful Links Explore the following resources to learn more about the project and see it in action: Training Training Repository A repository to learn how to use the project. Templates Project Template A template to start a new project. Project Links PyPI The project on PyPI. GitHub The project on GitHub. Demos Flask Demo Demonstrates how to use the project with Flask. FastAPI Demo Demonstrates how to use the project with FastAPI. Django Demo Demonstrates how to use the project with Django. Kafka Demo Example of using the project with Kafka. RAG Demo Example of using the project with RAG. IRIS Chemical Example of extracting chemical properties. Rest to DICOM Example of using the project with RestToDicom. OCR Example of using the project with an OCR engine.","title":"Useful Links"},{"location":"useful-links/#useful-links","text":"Explore the following resources to learn more about the project and see it in action:","title":"Useful Links"},{"location":"useful-links/#training","text":"Training Repository A repository to learn how to use the project.","title":"Training"},{"location":"useful-links/#templates","text":"Project Template A template to start a new project.","title":"Templates"},{"location":"useful-links/#project-links","text":"PyPI The project on PyPI. GitHub The project on GitHub.","title":"Project Links"},{"location":"useful-links/#demos","text":"Flask Demo Demonstrates how to use the project with Flask. FastAPI Demo Demonstrates how to use the project with FastAPI. Django Demo Demonstrates how to use the project with Django. Kafka Demo Example of using the project with Kafka. RAG Demo Example of using the project with RAG. IRIS Chemical Example of extracting chemical properties. Rest to DICOM Example of using the project with RestToDicom. OCR Example of using the project with an OCR engine.","title":"Demos"},{"location":"getting-started/first-steps/","text":"Getting Started with Interoperability On Python Welcome to the guide on getting started with Interoperability Embedded Python. This document will walk you through the initial steps to set up and begin using Python in your interoperability projects. Prerequisites Before you begin, ensure you have the following: A working installation of InterSystems IRIS with Embedded Python configured Basic knowledge of Python programming Setting Up the Virtual Environment To begin, you will need to set up a virtual environment for your Python project. A virtual environment is a self-contained directory that contains a Python installation for a particular version of Python, as well as any additional packages you may need for your project. To create a virtual environment, run the following command in your terminal: python -m venv .venv This will create a new directory called .venv in your project directory, which will contain the Python interpreter and any packages you install. Next, activate the virtual environment by running the following command: For Unix or MacOS: source .venv/bin/activate For Windows: .venv\\Scripts\\activate You should now see the name of your virtual environment in your terminal prompt, indicating that the virtual environment is active. Installing Required Packages With your virtual environment activated, you can now install any required packages for your project. To install a package, use the pip command followed by the package name. For example, to install the iris-pex-embedded-python package, run the following command: pip install iris-pex-embedded-python Init the application using the following command: iop --init This will install the package and any dependencies it requires. Hello World Now that you have set up your virtual environment and installed the required packages, you are ready to create your first Interoperability production using Python. Create a Business Operation For this, we will create an BusinessOperation that will take a message as input and will return a message as output. In between, it will just print \"Hello World\" in the logs. To do this, let's create a new folder named hello_world . mkdir hello_world In this folder, create a new file named bo.py . This file will contain the code of our business operation. from iop import BusinessOperation class MyBo(BusinessOperation): def on_message(self, request): self.log_info(\"Hello World\") Let's explain this code. First, we import the BusinessOperation class from the iop module. Then, we create a class named MyBo that inherits from BusinessOperation . Finally, we override the on_message method. This method will be called when a message is received by the business operation. Import this Business Operation in the framework Now, we need to add this business operation to what we call a production. To do this, we will create a new file in the hello_world folder, named settings.py . Every project starts at it's root folder by a file named settings.py . This file contains two main settings: CLASSES : it contains the classes that will be used in the project. PRODUCTIONS : it contains the name of the production that will be used in the project. from hello_world.bo import MyBo CLASSES = { \"MyIRIS.MyBo\": MyBo } PRODUCTIONS = [ { 'MyIRIS.Production': { \"@TestingEnabled\": \"true\", \"Item\": [ { \"@Name\": \"Instance.Of.MyBo\", \"@ClassName\": \"MyIRIS.MyBo\", } ] } } ] In this file, we import our MyBo class named in iris MyIRIS.MyBo , and we add it to the CLASSES dictionnary. Then, we add a new production to the PRODUCTIONS list. This production will contain our MyBo class instance named Instance.Of.MyBo . With the iop command, we can now create the production in IRIS. iop --migrate /path/to/hello_world/settings.py This command will create the production in IRIS and add the MyBo class to it. More information about registering components can be found here .","title":"First Steps"},{"location":"getting-started/first-steps/#getting-started-with-interoperability-on-python","text":"Welcome to the guide on getting started with Interoperability Embedded Python. This document will walk you through the initial steps to set up and begin using Python in your interoperability projects.","title":"Getting Started with Interoperability On Python"},{"location":"getting-started/first-steps/#prerequisites","text":"Before you begin, ensure you have the following: A working installation of InterSystems IRIS with Embedded Python configured Basic knowledge of Python programming","title":"Prerequisites"},{"location":"getting-started/first-steps/#setting-up-the-virtual-environment","text":"To begin, you will need to set up a virtual environment for your Python project. A virtual environment is a self-contained directory that contains a Python installation for a particular version of Python, as well as any additional packages you may need for your project. To create a virtual environment, run the following command in your terminal: python -m venv .venv This will create a new directory called .venv in your project directory, which will contain the Python interpreter and any packages you install. Next, activate the virtual environment by running the following command: For Unix or MacOS: source .venv/bin/activate For Windows: .venv\\Scripts\\activate You should now see the name of your virtual environment in your terminal prompt, indicating that the virtual environment is active.","title":"Setting Up the Virtual Environment"},{"location":"getting-started/first-steps/#installing-required-packages","text":"With your virtual environment activated, you can now install any required packages for your project. To install a package, use the pip command followed by the package name. For example, to install the iris-pex-embedded-python package, run the following command: pip install iris-pex-embedded-python Init the application using the following command: iop --init This will install the package and any dependencies it requires.","title":"Installing Required Packages"},{"location":"getting-started/first-steps/#hello-world","text":"Now that you have set up your virtual environment and installed the required packages, you are ready to create your first Interoperability production using Python.","title":"Hello World"},{"location":"getting-started/first-steps/#create-a-business-operation","text":"For this, we will create an BusinessOperation that will take a message as input and will return a message as output. In between, it will just print \"Hello World\" in the logs. To do this, let's create a new folder named hello_world . mkdir hello_world In this folder, create a new file named bo.py . This file will contain the code of our business operation. from iop import BusinessOperation class MyBo(BusinessOperation): def on_message(self, request): self.log_info(\"Hello World\") Let's explain this code. First, we import the BusinessOperation class from the iop module. Then, we create a class named MyBo that inherits from BusinessOperation . Finally, we override the on_message method. This method will be called when a message is received by the business operation.","title":"Create a Business Operation"},{"location":"getting-started/first-steps/#import-this-business-operation-in-the-framework","text":"Now, we need to add this business operation to what we call a production. To do this, we will create a new file in the hello_world folder, named settings.py . Every project starts at it's root folder by a file named settings.py . This file contains two main settings: CLASSES : it contains the classes that will be used in the project. PRODUCTIONS : it contains the name of the production that will be used in the project. from hello_world.bo import MyBo CLASSES = { \"MyIRIS.MyBo\": MyBo } PRODUCTIONS = [ { 'MyIRIS.Production': { \"@TestingEnabled\": \"true\", \"Item\": [ { \"@Name\": \"Instance.Of.MyBo\", \"@ClassName\": \"MyIRIS.MyBo\", } ] } } ] In this file, we import our MyBo class named in iris MyIRIS.MyBo , and we add it to the CLASSES dictionnary. Then, we add a new production to the PRODUCTIONS list. This production will contain our MyBo class instance named Instance.Of.MyBo . With the iop command, we can now create the production in IRIS. iop --migrate /path/to/hello_world/settings.py This command will create the production in IRIS and add the MyBo class to it. More information about registering components can be found here .","title":"Import this Business Operation in the framework"},{"location":"getting-started/installation/","text":"Installation Guide Welcome to the installation guide for IoP. This guide will walk you through the steps to install the application on your local machine or in a docker container image. Prerequisites Before you begin, ensure you have the following installed: Python 3.6 or higher IRIS 2021.2 or higher Configuring Embedded Python With PyPi To install the application using PyPi, run the following command: pip install iris-pex-embedded-python Then you can run the application using the following command: iop --init Check the documentation about the command line interface here for more information. With ZPM/IPM To install the application using ZPM or IPM, run the following command: zpm \"install iris-pex-embedded-python\"","title":"Installation"},{"location":"getting-started/installation/#installation-guide","text":"Welcome to the installation guide for IoP. This guide will walk you through the steps to install the application on your local machine or in a docker container image.","title":"Installation Guide"},{"location":"getting-started/installation/#prerequisites","text":"Before you begin, ensure you have the following installed: Python 3.6 or higher IRIS 2021.2 or higher Configuring Embedded Python","title":"Prerequisites"},{"location":"getting-started/installation/#with-pypi","text":"To install the application using PyPi, run the following command: pip install iris-pex-embedded-python Then you can run the application using the following command: iop --init Check the documentation about the command line interface here for more information.","title":"With PyPi"},{"location":"getting-started/installation/#with-zpmipm","text":"To install the application using ZPM or IPM, run the following command: zpm \"install iris-pex-embedded-python\"","title":"With ZPM/IPM"},{"location":"getting-started/register-component/","text":"Registering Components There are two main ways to register your Python components with IRIS Interoperability: With a settings file With a Python script: Register a single component using register_component Register all components in a file using register_file Register all components in a folder using register_folder With a Settings File Create a settings.py file in the root of your project. This file will be used to register your classes and productions. Example of settings.py import bo CLASSES = { \"Python.MyBusinessOperation\": bo.MyBusinessOperation } Registering the Component Use the iop command line to register your component: iop --migrate /path/to/your/project/setting.py Using the Python Shell Registering a Single Component Use the register_component method to add a new Python file to the component list for interoperability. from iop import Utils Utils.register_component(<ModuleName>,<ClassName>,<PathToPyFile>,<OverWrite>,<NameOfTheComponent>) Example: from iop import Utils Utils.register_component(\"MyCombinedBusinessOperation\",\"MyCombinedBusinessOperation\",\"/irisdev/app/src/python/demo/\",1,\"PEX.MyCombinedBusinessOperation\") Registering All Components in a File Use the register_file method to add all components in a file to the component list for interoperability. from iop import Utils Utils.register_file(<File>,<OverWrite>,<PackageName>) Example: from iop import Utils Utils.register_file(\"/irisdev/app/src/python/demo/bo.py\",1,\"PEX\") Registering All Components in a Folder Use the register_folder method to add all components in a folder to the component list for interoperability. from iop import Utils Utils.register_folder(<Path>,<OverWrite>,<PackageName>) Example: from iop import Utils Utils.register_folder(\"/irisdev/app/src/python/demo/\",1,\"PEX\") Migrating Settings Use the migrate method to migrate the settings file to the IRIS framework. from iop import Utils Utils.migrate() The settings.py File This file is used to store the settings of the interoperability components. It has three sections: CLASSES : Stores the classes of the interoperability components. PRODUCTIONS : Stores the productions of the interoperability components. SCHEMAS : Stores the schemas of the interoperability components. Example: import bp from bo import * from bs import * from msg import RedditPost CLASSES = { 'Python.RedditService': RedditService, 'Python.FilterPostRoutingRule': bp.FilterPostRoutingRule, 'Python.FileOperation': FileOperation, 'Python.FileOperationWithIrisAdapter': FileOperationWithIrisAdapter, } SCHEMAS = [RedditPost] PRODUCTIONS = [ { 'dc.Python.Production': { \"@Name\": \"dc.Demo.Production\", \"@TestingEnabled\": \"true\", \"@LogGeneralTraceEvents\": \"false\", \"Description\": \"\", \"ActorPoolSize\": \"2\", \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@Category\": \"\", \"@ClassName\": \"Python.FileOperation\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"true\", \"@Schedule\": \"\", \"Setting\": { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": \"path=/tmp\" } }, { \"@Name\": \"Python.RedditService\", \"@Category\": \"\", \"@ClassName\": \"Python.RedditService\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"false\", \"@Schedule\": \"\", \"Setting\": [ { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": \"limit=10\\nother<10\" } ] }, { \"@Name\": \"Python.FilterPostRoutingRule\", \"@Category\": \"\", \"@ClassName\": \"Python.FilterPostRoutingRule\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"false\", \"@Schedule\": \"\" } ] } } ] The CLASSES Section This section stores the classes of the interoperability components. It helps to register the components. The dictionary has the following structure: Key: The name of the component Value: The class of the component (you have to import it before) The module of the component (you have to import it before) Another dictionary with the following structure: module : Name of the module of the component (optional) class : Name of the class of the component (optional) path : The path of the component (mandatory) Example: When Value is a class or a module: import bo import bp from bs import RedditService CLASSES = { 'Python.RedditService': RedditService, 'Python.FilterPostRoutingRule': bp.FilterPostRoutingRule, 'Python.FileOperation': bo, } When Value is a dictionary: CLASSES = { 'Python.RedditService': { 'module': 'bs', 'class': 'RedditService', 'path': '/irisdev/app/src/python/demo/' }, 'Python.Module': { 'module': 'bp', 'path': '/irisdev/app/src/python/demo/' }, 'Python.Package': { 'path': '/irisdev/app/src/python/demo/' }, } The PRODUCTIONS Section This section stores the productions of the interoperability components. It helps to register a production. The list has the following structure: A list of dictionaries with the following structure: dc.Python.Production : The name of the production @Name : The name of the production @TestingEnabled : The testing enabled of the production @LogGeneralTraceEvents : The log general trace events of the production Description : The description of the production ActorPoolSize : The actor pool size of the production Item : The list of the items of the production @Name : The name of the item @Category : The category of the item @ClassName : The class name of the item @PoolSize : The pool size of the item @Enabled : The enabled of the item @Foreground : The foreground of the item @Comment : The comment of the item @LogTraceEvents : The log trace events of the item @Schedule : The schedule of the item Setting : The list of the settings of the item @Target : The target of the setting @Name : The name of the setting #text : The value of the setting The minimum structure of a production is: PRODUCTIONS = [ { 'UnitTest.Production': { \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@ClassName\": \"Python.FileOperation\", }, { \"@Name\": \"Python.EmailOperation\", \"@ClassName\": \"UnitTest.Package.EmailOperation\" } ] } } ] You can also set in @ClassName an item from the CLASSES section. Example: from bo import FileOperation PRODUCTIONS = [ { 'UnitTest.Production': { \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@ClassName\": FileOperation, } ] } } ] As the production is a dictionary, you can add in the value of the production dictionary an environment variable. Example: import os PRODUCTIONS = [ { 'UnitTest.Production': { \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@ClassName\": \"Python.FileOperation\", \"Setting\": { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": os.environ['SETTINGS'] } } ] } } ] The SCHEMAS Section This section stores the schemas of the interoperability components. It helps to register the schemas for DTL transformations. The list has the following structure: A list of classes Example: from msg import RedditPost SCHEMAS = [RedditPost]","title":"Register Component"},{"location":"getting-started/register-component/#registering-components","text":"There are two main ways to register your Python components with IRIS Interoperability: With a settings file With a Python script: Register a single component using register_component Register all components in a file using register_file Register all components in a folder using register_folder","title":"Registering Components"},{"location":"getting-started/register-component/#with-a-settings-file","text":"Create a settings.py file in the root of your project. This file will be used to register your classes and productions.","title":"With a Settings File"},{"location":"getting-started/register-component/#example-of-settingspy","text":"import bo CLASSES = { \"Python.MyBusinessOperation\": bo.MyBusinessOperation }","title":"Example of settings.py"},{"location":"getting-started/register-component/#registering-the-component","text":"Use the iop command line to register your component: iop --migrate /path/to/your/project/setting.py","title":"Registering the Component"},{"location":"getting-started/register-component/#using-the-python-shell","text":"","title":"Using the Python Shell"},{"location":"getting-started/register-component/#registering-a-single-component","text":"Use the register_component method to add a new Python file to the component list for interoperability. from iop import Utils Utils.register_component(<ModuleName>,<ClassName>,<PathToPyFile>,<OverWrite>,<NameOfTheComponent>) Example: from iop import Utils Utils.register_component(\"MyCombinedBusinessOperation\",\"MyCombinedBusinessOperation\",\"/irisdev/app/src/python/demo/\",1,\"PEX.MyCombinedBusinessOperation\")","title":"Registering a Single Component"},{"location":"getting-started/register-component/#registering-all-components-in-a-file","text":"Use the register_file method to add all components in a file to the component list for interoperability. from iop import Utils Utils.register_file(<File>,<OverWrite>,<PackageName>) Example: from iop import Utils Utils.register_file(\"/irisdev/app/src/python/demo/bo.py\",1,\"PEX\")","title":"Registering All Components in a File"},{"location":"getting-started/register-component/#registering-all-components-in-a-folder","text":"Use the register_folder method to add all components in a folder to the component list for interoperability. from iop import Utils Utils.register_folder(<Path>,<OverWrite>,<PackageName>) Example: from iop import Utils Utils.register_folder(\"/irisdev/app/src/python/demo/\",1,\"PEX\")","title":"Registering All Components in a Folder"},{"location":"getting-started/register-component/#migrating-settings","text":"Use the migrate method to migrate the settings file to the IRIS framework. from iop import Utils Utils.migrate()","title":"Migrating Settings"},{"location":"getting-started/register-component/#the-settingspy-file","text":"This file is used to store the settings of the interoperability components. It has three sections: CLASSES : Stores the classes of the interoperability components. PRODUCTIONS : Stores the productions of the interoperability components. SCHEMAS : Stores the schemas of the interoperability components. Example: import bp from bo import * from bs import * from msg import RedditPost CLASSES = { 'Python.RedditService': RedditService, 'Python.FilterPostRoutingRule': bp.FilterPostRoutingRule, 'Python.FileOperation': FileOperation, 'Python.FileOperationWithIrisAdapter': FileOperationWithIrisAdapter, } SCHEMAS = [RedditPost] PRODUCTIONS = [ { 'dc.Python.Production': { \"@Name\": \"dc.Demo.Production\", \"@TestingEnabled\": \"true\", \"@LogGeneralTraceEvents\": \"false\", \"Description\": \"\", \"ActorPoolSize\": \"2\", \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@Category\": \"\", \"@ClassName\": \"Python.FileOperation\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"true\", \"@Schedule\": \"\", \"Setting\": { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": \"path=/tmp\" } }, { \"@Name\": \"Python.RedditService\", \"@Category\": \"\", \"@ClassName\": \"Python.RedditService\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"false\", \"@Schedule\": \"\", \"Setting\": [ { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": \"limit=10\\nother<10\" } ] }, { \"@Name\": \"Python.FilterPostRoutingRule\", \"@Category\": \"\", \"@ClassName\": \"Python.FilterPostRoutingRule\", \"@PoolSize\": \"1\", \"@Enabled\": \"true\", \"@Foreground\": \"false\", \"@Comment\": \"\", \"@LogTraceEvents\": \"false\", \"@Schedule\": \"\" } ] } } ]","title":"The settings.py File"},{"location":"getting-started/register-component/#the-classes-section","text":"This section stores the classes of the interoperability components. It helps to register the components. The dictionary has the following structure: Key: The name of the component Value: The class of the component (you have to import it before) The module of the component (you have to import it before) Another dictionary with the following structure: module : Name of the module of the component (optional) class : Name of the class of the component (optional) path : The path of the component (mandatory) Example: When Value is a class or a module: import bo import bp from bs import RedditService CLASSES = { 'Python.RedditService': RedditService, 'Python.FilterPostRoutingRule': bp.FilterPostRoutingRule, 'Python.FileOperation': bo, } When Value is a dictionary: CLASSES = { 'Python.RedditService': { 'module': 'bs', 'class': 'RedditService', 'path': '/irisdev/app/src/python/demo/' }, 'Python.Module': { 'module': 'bp', 'path': '/irisdev/app/src/python/demo/' }, 'Python.Package': { 'path': '/irisdev/app/src/python/demo/' }, }","title":"The CLASSES Section"},{"location":"getting-started/register-component/#the-productions-section","text":"This section stores the productions of the interoperability components. It helps to register a production. The list has the following structure: A list of dictionaries with the following structure: dc.Python.Production : The name of the production @Name : The name of the production @TestingEnabled : The testing enabled of the production @LogGeneralTraceEvents : The log general trace events of the production Description : The description of the production ActorPoolSize : The actor pool size of the production Item : The list of the items of the production @Name : The name of the item @Category : The category of the item @ClassName : The class name of the item @PoolSize : The pool size of the item @Enabled : The enabled of the item @Foreground : The foreground of the item @Comment : The comment of the item @LogTraceEvents : The log trace events of the item @Schedule : The schedule of the item Setting : The list of the settings of the item @Target : The target of the setting @Name : The name of the setting #text : The value of the setting The minimum structure of a production is: PRODUCTIONS = [ { 'UnitTest.Production': { \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@ClassName\": \"Python.FileOperation\", }, { \"@Name\": \"Python.EmailOperation\", \"@ClassName\": \"UnitTest.Package.EmailOperation\" } ] } } ] You can also set in @ClassName an item from the CLASSES section. Example: from bo import FileOperation PRODUCTIONS = [ { 'UnitTest.Production': { \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@ClassName\": FileOperation, } ] } } ] As the production is a dictionary, you can add in the value of the production dictionary an environment variable. Example: import os PRODUCTIONS = [ { 'UnitTest.Production': { \"Item\": [ { \"@Name\": \"Python.FileOperation\", \"@ClassName\": \"Python.FileOperation\", \"Setting\": { \"@Target\": \"Host\", \"@Name\": \"%settings\", \"#text\": os.environ['SETTINGS'] } } ] } } ]","title":"The PRODUCTIONS Section"},{"location":"getting-started/register-component/#the-schemas-section","text":"This section stores the schemas of the interoperability components. It helps to register the schemas for DTL transformations. The list has the following structure: A list of classes Example: from msg import RedditPost SCHEMAS = [RedditPost]","title":"The SCHEMAS Section"}]}